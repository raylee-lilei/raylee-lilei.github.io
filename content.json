{"meta":{"title":"raylee","subtitle":null,"description":"raylee personal blog","author":"raylee","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-29T05:50:54.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Hello,raylee] 与&nbsp; raylee&nbsp; （ Love greetings ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-04-03T07:54:52.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"C++","date":"2020-04-08T09:14:47.000Z","updated":"2020-04-13T10:59:32.000Z","comments":true,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"剑指offer每日一题 |这里将是永远的回忆 1. 个人主页 CSDN 我的技术栈 2. 个人项目 Gitee 我的项目 Github 我的项目 3. 个人定制工具 colordrop 在线配色 cdn 我的图床 素材图库 picabay 插画图片 4. 主题相关 hojun 一个好奇的博客 Mashiro 樱花庄的白猫 5. 学习的好地方 牛客网 在线编程 Vue 前端组件 BootStrap 前端样式 6. 小伙伴们 欢迎交换友链 ꉂ(ˊᗜˋ) Yremp 流年，谁给过的倾城 wallleap 今日事,今日畢 爆胎 互联网工厂长方形物体空间移动师 林木木 木木木木 Uncle_drew Hand down,man down. Admax 奇妙的记录者 R 喵呜的小窝 FE Node 一去二三遥 一个想当摄影师却被迫写代码的厨子 秦枫鸢梦 花有重开日，人无再少年 不一止集 热爱生活，喜欢摄影，是个笨人 夏目贵志 热爱生活 喜欢大自然 实力派 Sanarous 码农人生 Muyulong’s Blog 菜鸡一个，啥也不会。 uncledemon 同窗 HKU’BLOG 一个基于人文关怀，和IT教程分享的博客网站。 单林敏 心外无物，知行合一 Leaface Stay hungry Stay Foolish 刘旺学长 乐于分享技术的宝藏博主 缓归’s Blog 虽言缓归，实则盼归。 混世大魔王 一个无意间的blog lxxs I pray to myself 留梦 人生如水，梦如泉。 尼采般地抒情 总结技术，记录生活。 云开、见月明 梦醒繁华，一城荒芜！ Sand sculpture 沙雕 blog 前端爱好者痴笑 一个前端爱好者的个人生活日记簿 Blue 代码是热爱，写到世界充满爱！ 断桥烟雨 一万年太久只争朝夕 xiangyi xiangyi’s 黑板报 易与天行 一个物联网专业，却喜欢编程的小白","keywords":"剑指offer"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-29T06:02:04.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-29T06:00:04.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"resume","date":"2018-12-20T15:13:35.000Z","updated":"2020-08-24T02:41:34.210Z","comments":false,"path":"download/index.html","permalink":"/download/index.html","excerpt":"","text":"点击下载查看","keywords":"我的简历"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2020-03-28T15:11:06.000Z","updated":"2020-03-29T06:07:40.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-29T06:08:52.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"","date":"2020-08-12T08:12:24.501Z","updated":"2020-05-02T10:17:26.000Z","comments":true,"path":"offer/index.html","permalink":"/offer/index.html","excerpt":"","text":"剑指offer每日一题 |这里将是永远的回忆 C++每日一题 开始吧 数组 在一个二维数组中寻找某个数是否存在 字符串替换 将一个字符串中的每个空格替换成“%20“ 链表逆序 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 二叉树还原 输入某二叉树的前序遍历和中序遍历，重构二叉树 栈实现队列 用两个栈来实现一个队列 旋转数组查找最小值 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 斐波那契数列 要求输入一个整数n，请你输出斐波那契数列的第n项 位操作 输入一个整数，输出该数二进制表示中1的个数 指数计算 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 数组调序 输入一个整数数组，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 链表查询、反转 输入一个链表，输出该链表中倒数第k个结点。 链表合并 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 二叉树遍历 输入两棵二叉树A，B，判断B是不是A的子结构。 二叉树镜像 操作给定的二叉树，将其变换为源二叉树的镜像。 矩阵顺时针旋转输出 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字 栈找Min 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数 栈弹出 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。 二叉树层次遍历 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 二叉搜索树 输入一个非空整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。 二叉树路径等于输入值 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。"},{"title":"tags","date":"2020-03-28T14:14:16.000Z","updated":"2020-03-29T05:47:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-29T06:13:24.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""}],"posts":[{"title":"CPP总结思维导图","slug":"CPP总结思维导图","date":"2020-08-24T02:42:34.000Z","updated":"2020-08-24T02:58:16.392Z","comments":true,"path":"2020/08/24/CPP总结思维导图/","link":"","permalink":"/2020/08/24/CPP总结思维导图/","excerpt":"","text":"","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"algorithm总结思维导图","slug":"algorithm总结思维导图","date":"2020-08-24T02:42:25.000Z","updated":"2020-08-24T02:56:49.795Z","comments":true,"path":"2020/08/24/algorithm总结思维导图/","link":"","permalink":"/2020/08/24/algorithm总结思维导图/","excerpt":"","text":"","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"SQL总结思维导图","slug":"SQL总结思维导图","date":"2020-08-24T02:42:10.000Z","updated":"2020-08-24T02:58:53.600Z","comments":true,"path":"2020/08/24/SQL总结思维导图/","link":"","permalink":"/2020/08/24/SQL总结思维导图/","excerpt":"","text":"","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"OS总结思维导图","slug":"OS总结思维导图","date":"2020-08-24T02:41:58.000Z","updated":"2020-08-24T02:59:23.843Z","comments":true,"path":"2020/08/24/OS总结思维导图/","link":"","permalink":"/2020/08/24/OS总结思维导图/","excerpt":"","text":"","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"计算机网络总结思维导图","slug":"计算机网络总结思维导图","date":"2020-08-24T02:05:30.000Z","updated":"2020-08-24T02:48:03.657Z","comments":true,"path":"2020/08/24/计算机网络总结思维导图/","link":"","permalink":"/2020/08/24/计算机网络总结思维导图/","excerpt":"","text":"","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十九）","slug":"C-剑指offer刷题（五十九）","date":"2020-06-30T03:42:02.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/30/C-剑指offer刷题（五十九）/","link":"","permalink":"/2020/06/30/C-剑指offer刷题（五十九）/","excerpt":"","text":"题目描述给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 思路:动态规划 codeclass Solution { public: int cutRope(int number) { if(number&lt;=3){ return number-1; } //记录最大值 int dp[number+1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; int res = 0; for(int i =4;i&lt;=number;++i){ for(int j =1;j&lt;=i/2;++j){ res = max(res,dp[j]*dp[i-j]); } dp[i] = res; } return dp[number]; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十八）","slug":"C-剑指offer刷题（五十八）","date":"2020-06-30T03:40:09.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/30/C-剑指offer刷题（五十八）/","link":"","permalink":"/2020/06/30/C-剑指offer刷题（五十八）/","excerpt":"","text":"题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路:回溯1. 定义有一个和矩阵一样的一维数组，初始化为02. 首先要判断上下左右是否划出了边界3. 数位值之和大于阈值，已近走过4. 递归找这个值上下左右的位置，满足条件计数加一 codeclass Solution { public: int movingCount(int threshold, int rows, int cols) { //定义 一个二维矩阵记录标记 vector&lt;vector&lt;int&gt;&gt; flag(rows); //行 for(int i =0;i&lt;rows;i++){ //列 flag[i].resize(cols); } return DFS(threshold, rows, cols,flag,0,0); } int DFS(int threshold, int rows, int cols,vector&lt;vector&lt;int&gt;&gt; &amp;flag,int i,int j){ if(i&lt;0 || i&gt;=rows ||j&lt;0 || j&gt;=cols || CountSum(i)+CountSum(j) &gt; threshold || flag[i][j]== 1){ return 0; } flag[i][j]= 1; return 1 +DFS(threshold,rows, cols,flag,i-1,j) +DFS(threshold,rows, cols,flag,i+1,j) +DFS(threshold,rows, cols,flag,i,j-1) +DFS(threshold,rows, cols,flag,i,j+1); } int CountSum(int i){ int sum = 0; while(i&gt;0){ sum += i % 10; i /= 10; } return sum; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十七）","slug":"C-剑指offer刷题（五十七）","date":"2020-06-30T03:40:03.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/30/C-剑指offer刷题（五十七）/","link":"","permalink":"/2020/06/30/C-剑指offer刷题（五十七）/","excerpt":"","text":"题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如【a&emsp; b&emsp; c&emsp; e &emsp;&emsp;&emsp;s&emsp; f &emsp; c &emsp;s &emsp;&emsp;&emsp; a&emsp; d&emsp; e&emsp; e】矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 思路:回溯 //矩阵是一维的[a b c e s f c s a d e e] //字符串一维 b c c e d //找一个标志位实际上是和矩阵一样的一个数组 用来判断是否走过 0 未走过 1 表示走过1. 定义有一个和矩阵一样的一维数组，初始化为02. 遍历矩阵，找字符串第一个在矩阵中的位置（首先要判断上下左右是否划出了边界）3. 修改标志位的值，表示这个位置已经走过4. 判断下str下一个是否是最后一个5. 找这个值上下左右的位置6. 没找到这个字符的上下左右是字符串中的路径，当前值变为未走过，继续去找下一个 codeclass Solution { public: bool hasPath(char* matrix, int rows, int cols, char* str) { //矩阵是一维的[a b c e s f c s a d e e] //字符串一维 b c c e d //找一个标志位实际上是和矩阵一样的一个数组 用来判断是否走过 0 未走过 1 表示走过 vector&lt;char&gt; flag(rows*cols,0); bool Result = false; //遍历矩阵 for(int i = 0;i &lt; rows;++i){ for(int j = 0;j&lt; cols;++j){ Result = (Result || IsPath(matrix,flag,i,j,str,rows,cols)); } } return Result; } bool IsPath(char* matrix,vector&lt;char&gt; flag,int x,int y,char *str,int rows, int cols){ //判断是否溢出了矩阵的边界 if(x&lt;0 || x&gt;= rows || y&lt;0 || y&gt;=cols){ return false; } //找字符串第一个在矩阵中的位置 if(matrix[x*cols+y] == *str &amp;&amp; flag[x*cols+y] == 0){ //修改标志位的值，表示这个位置已经走过 flag[x*cols+y] = 1; //判断下str 是否是最后一个 if(*(str+1)==0){ return true; } //找这个值上下左右的位置 bool Result = IsPath(matrix,flag,x,y+1,str+1,rows,cols) || IsPath(matrix,flag,x-1,y,str+1,rows,cols) || IsPath(matrix,flag,x+1,y,str+1,rows,cols) || IsPath(matrix,flag,x,y-1,str+1,rows,cols); //没找到这个字符的上下左右是字符串中的路径，当前值变为未走过 if(Result == false){ flag[x*cols+y] = 0; } return Result; }else{ return false; } } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十六）","slug":"C-剑指offer刷题（五十六）","date":"2020-06-30T03:39:55.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/30/C-剑指offer刷题（五十六）/","link":"","permalink":"/2020/06/30/C-剑指offer刷题（五十六）/","excerpt":"","text":"题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 思路:队列1. 定义一个队列，存放数组的下标2. 当后一个比 队列中下标的值大，删除队列中的元素（最大的排在最前面）3. 队列中插入下标4. 如果窗口都划出了size个了，某个值还是最大，删除前面的大值5. 只要大于3之后每次都将队列最前面的值插入结果中 codeclass Solution { public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) { vector&lt;int&gt; result; if(size&lt;1 || num.size()&lt;size){ return result; } deque&lt;int&gt; qmax; for(int i=0; i&lt;num.size(); ++i){ //遍历大小，最大的排在最前面 while(!qmax.empty() &amp;&amp; num[qmax.back()]&lt;=num[i]){ qmax.pop_back(); } //队列插入下标 qmax.push_back(i); //如果窗口都划出了size个了，某个值还是最大，删除前面的大值 if(qmax.front() == i-size) { qmax.pop_front(); } //只要大于3之后每次都将最前面的值插入结果中 if(i &gt;= size - 1){ result.push_back(num[qmax.front()]); } } return result; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十五）","slug":"C-剑指offer刷题（五十五）","date":"2020-06-30T03:39:50.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/30/C-剑指offer刷题（五十五）/","link":"","permalink":"/2020/06/30/C-剑指offer刷题（五十五）/","excerpt":"","text":"题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 思路一 :STL upper_bound()1. 插入数组时，使用upper_bound(),返回数组中最后一个大于等于num 的值2. 找中位数如果为偶数返回中间两个值的平均3. 如果为奇数，返回中间值 思路二 :优先队列 priority_queue&lt;int, vector,greater&gt; right;//越小越优先[5,6,7] 拿出5 小根堆（数较大） 升序优先队列，优先删除最小 的 priority_queue&lt;int, vector,less&gt; left; //越大越优先 [4,3,1]拿出4 大根 对（数较小） 降序 优先删除最大的1. 将数组划分两个数组流2. 先放入往左边数组放一个值 ，根据大小顶对的特点插入数据3. 最终大根堆降序，小根堆升序4. 取出中位数 codeclass Solution { public: #if 0 vector&lt;int&gt; DataStream; void Insert(int num) { //使用STL中upper_bound(),返回数组中最后一个大于等于num 的值 auto position = upper_bound(DataStream.begin(), DataStream.end(), num); DataStream.insert(position, num); } double GetMedian() { int size = DataStream.size(); if(size%2==0){ return 1.0*(DataStream[size/2-1]+DataStream[size/2])/2; }else{ return DataStream[size/2]*1.0; } } #endif //[1,3,4,5,6,7] [1,3,4]和[5,6,7] //优先队列 priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; right;//越小越优先[1,3,4] 拿出4 priority_queue&lt;int, vector&lt;int&gt;,less&lt;int&gt;&gt; left; //越大越优先[5,6,7] 拿出5 void Insert(int num) { left.push(num); if(left.size()-right.size()&gt;1) { //从大根堆拿最大的元素在小根 堆中 right.push(left.top()); left.pop(); } if(right.size()&gt;0 &amp;&amp; left.top()&gt;right.top()){ int tmp=left.top(); left.pop(); left.push(right.top()); right.pop(); right.push(tmp); } } double GetMedian() { if(left.size()==right.size()) return 1.0*(left.top()+right.top())/2; else return left.top(); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十四）","slug":"C-剑指offer刷题（五十四）","date":"2020-06-30T03:39:17.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/30/C-剑指offer刷题（五十四）/","link":"","permalink":"/2020/06/30/C-剑指offer刷题（五十四）/","excerpt":"","text":"题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 思路:遍历1. 定义 一个标记位2. 判断第一个为‘-’，标记位为 -1，否则为13. 开始遍历，若果第一个字符为‘-’，就从第二个位置开始4. 判断后面的字符是否是数字5. 转化为数字6. 乘以标记位得到结果 codeclass Solution { public: int StrToInt(string str) { int len=str.length(); int result; if(len&lt;0) result=0; int flag; if(str[0]==&#39;-&#39;) flag=-1; else flag=1; for(int i=(str[i]==&#39;-&#39;||str[i]==&#39;+&#39;)?1:0;i&lt;len;++i) { if(!(str[i]&gt;=&#39;0&#39;&amp;&amp;str[i]&lt;=&#39;9&#39;))//不在范围内的返回0 { return 0; } result=result*10+str[i]-&#39;0&#39;;//范围内的字符转换为整数 } return result*flag; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十三）","slug":"C-剑指offer刷题（五十三）","date":"2020-06-20T04:58:25.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/20/C-剑指offer刷题（五十三）/","link":"","permalink":"/2020/06/20/C-剑指offer刷题（五十三）/","excerpt":"","text":"题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路:中序遍历的结果按照从小到大的顺序排列的1. 遍历左子树2. k–3. 如果k==0，res = 节点4. 遍历右子树 code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: TreeNode* res = NULL; //中序遍历结果就是从小到大顺序 TreeNode* KthNode(TreeNode* pRoot, int k) { DFS(pRoot,k); return res; } void DFS(TreeNode* pRoot, int &amp;k){ if(!pRoot){ return; } //左 DFS(pRoot-&gt;left,k); //根 k--; if(k==0){ res = pRoot; } //右 DFS(pRoot-&gt;right,k); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十二）","slug":"C-剑指offer刷题（五十二）","date":"2020-06-20T04:58:20.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/20/C-剑指offer刷题（五十二）/","link":"","permalink":"/2020/06/20/C-剑指offer刷题（五十二）/","excerpt":"","text":"题目描述请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树 思路:二叉树遍历1. 序列化（树——&gt;字符串）2. char——&gt;string3. 如果为空res = ‘#’4. 如果不为空，每个树节点之后加上字符”,”5. 遍历左子树6. 遍历右子树7. 反序列化（字符串——&gt;树）8. 计算下每个节点字符的长度9. 判断字符是否为空10. 定义一个符号位11. 如果字符串中遇到”-“符号位= -112. 计数指针向后移动一位13. 将每个节点的字符转成数字14. 数字乘上符号位15. 计数指针往后移动判断下一个节点的数字16. 生成二叉树（递归反序列化左子树、右子树） code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: char* Serialize(TreeNode *root) { string res; //深度优先遍历算法 DFS1(root,res); //string 转 char char* p = new char[res.size()]; strcpy(p, res.c_str()); return p; } //二叉树序列化 void DFS1(TreeNode *root,string &amp;res){ //遍历到空节点 if(!root){ res += &quot;#,&quot;; return; } //非空节点 res += to_string(root-&gt;val) + &quot;,&quot;; DFS1(root-&gt;left, res); DFS1(root-&gt;right, res); } //反序列化 TreeNode* Deserialize(char *str) { int index = 0; return DFS2(str,index); } //index 字符串串长度 TreeNode* DFS2(char *str,int &amp;index){ //确定每个数字 长度 135长度为3 3 长度1 int len = index; while(str[len] != &#39;,&#39;){ len++; } //空节点 if(str[index]==&#39;#&#39;){ index = len+1; return NULL; } //非空节点 int num = 0; //符号 int sign = 1; if(index&lt;len &amp;&amp; str[index] == &#39;-&#39;){ sign = -1; index++; } for(int i = index;i&lt;len;++i){ num = num *10 + str[i] - &#39;0&#39;; } num *= sign; //index往下走 index = len+1; auto root = new TreeNode(num); root-&gt;left = DFS2(str,index); root-&gt;right = DFS2(str,index); return root; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五十一）","slug":"C-剑指offer刷题（五十一）","date":"2020-06-20T04:58:12.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/20/C-剑指offer刷题（五十一）/","link":"","permalink":"/2020/06/20/C-剑指offer刷题（五十一）/","excerpt":"","text":"题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路:二叉树层次遍历1. 定义一个队列和一个指向队列头的指针2. 往队列里面添加树根3. 在队列不为空的条件下，定义一个临时数组4. 队列出队5. 向临时数组中添加指针指向的值6. 遍历每一层，将 每一层的值插入队列中7. 每一层的值放入Result中8. 返回Result code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt;&gt; Result; if(pRoot == NULL){ return Result; } TreeNode* MoveNode = NULL; queue&lt;TreeNode*&gt; queTree; queTree.push(pRoot); while(!queTree.empty()){ int size = queTree.size(); vector&lt;int&gt; temp; while(size--){ MoveNode = queTree.front(); queTree.pop(); temp.push_back(MoveNode-&gt;val); if(MoveNode-&gt;left!=NULL){ queTree.push(MoveNode-&gt;left); } if(MoveNode-&gt;right!=NULL){ queTree.push(MoveNode-&gt;right); } } Result.push_back(temp); } return Result; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"微信公众号文章","slug":"微信公众号文章","date":"2020-06-20T04:00:11.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/20/微信公众号文章/","link":"","permalink":"/2020/06/20/微信公众号文章/","excerpt":"","text":"微信公众号文章链接Linux你内核linux内核源码分析 C++C++基本知识点C++StudyC++数据结构和与算法C++学习之路 UbuntuUbuntu常用命令Ubuntu 软件安装双系统给Ubuntu扩容搬瓦工VPS+SS配置(windows/ubuntu)+git常用操作+NXP S32DS​Ubuntu18.04常用配置Win10+Ubuntu18.04 LTS双系统安装VMware中Ubuntu扩容Ubuntu18.04常用配置 gitgit常用命令使用记录 模式识别模式识别学习总结 深度学习Ubuntu18.04安装配置深度学习环境Ubuntu 18.04深度学习环境配置Windows Notebooks的安装和使用介绍 &amp; TensorFlow+openCV+Notebooks开发环境搭建 图论图论及其应用知识点总结 傅里叶变换快速傅里叶变换在信号处理中的应用 计算机视觉计算机视觉之Gamma变换、光流法、ACM轮廓提取学习Ubuntu 16.04使用cmake3.5.0安装OpenCV3.1.1/CMake+win10+vs2017+opencvCmake3.8.0+vs2017编译opencv库OpenCV安装及配置环境变量OpenCV学习笔记（一）OpenCV学习笔记（二）OpenCV学习笔记（三） pythonPython学习之路","categories":[{"name":"link","slug":"link","permalink":"/categories/link/"}],"tags":[],"keywords":[{"name":"link","slug":"link","permalink":"/categories/link/"}]},{"title":"C++剑指offer刷题（五十）","slug":"C-剑指offer刷题（五十）","date":"2020-06-17T13:37:24.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/17/C-剑指offer刷题（五十）/","link":"","permalink":"/2020/06/17/C-剑指offer刷题（五十）/","excerpt":"","text":"题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 思路:特点1. 左子树的左子树和右子树的右子树相等2. 左子树的右子树和右子树的左子树相等 code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: //左子树的左子树和右子树的右子树相等 //左子树的右子树和右子树的左子树相等 bool isSymmetrical(TreeNode* pRoot) { if(pRoot == NULL){ return true; } return IsMirror(pRoot-&gt;left,pRoot-&gt;right); } bool IsMirror(TreeNode* pRoot1,TreeNode* pRoot2){ if(pRoot1 == NULL &amp;&amp; pRoot2 == NULL){ return true; } if(pRoot1 == NULL || pRoot2 == NULL){ return false; } if(pRoot1-&gt;val != pRoot2-&gt;val){ return false; } return(IsMirror(pRoot1-&gt;left,pRoot2-&gt;right) &amp;&amp; IsMirror(pRoot1-&gt;right,pRoot2-&gt;left)); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十九）","slug":"C-剑指offer刷题（四十九）","date":"2020-06-17T13:13:44.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/17/C-剑指offer刷题（四十九）/","link":"","permalink":"/2020/06/17/C-剑指offer刷题（四十九）/","excerpt":"","text":"题目描述1请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 思路:层次遍历（之） 栈1. 定义两个栈存放每一层数2. 定义一个指针每次指向栈顶元素3. 先把根存放在栈1中4. 在栈1不为空的条件下遍历（奇数行从左到右）5. 栈1出栈，使用栈顶指针去找左右子树，分别压栈，存放在数组中6. 栈1存放奇数行，栈2存放偶数行7. 一层遍历完之后把每一层的结果放入Result中，并清除临时数组8. 在栈2不为空的条件下遍历（偶数行从右到左）9. 栈2出栈，使用栈顶指针去找左右子树，分别压栈，存放在数组中10. 一层遍历完之后把每一层的结果放入Result中，并清除临时数组11. 返回Result code1/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt; &gt; Result; if(pRoot == NULL){ return Result; } vector&lt;int&gt; Temp; stack&lt;TreeNode*&gt; Stack1; stack&lt;TreeNode*&gt; Stack2; TreeNode* MoveNode = NULL; Temp.push_back(pRoot-&gt;val); Result.push_back(Temp); Temp.clear(); Stack1.push(pRoot); while(!Stack1.empty() || !Stack2.empty()){ while(!Stack1.empty()){ MoveNode = Stack1.top(); Stack1.pop(); if(MoveNode-&gt;right){ Stack2.push(MoveNode-&gt;right); Temp.push_back(MoveNode-&gt;right-&gt;val); } if(MoveNode-&gt;left){ Stack2.push(MoveNode-&gt;left); Temp.push_back(MoveNode-&gt;left-&gt;val); } } if(!Temp.empty()){ Result.push_back(Temp); Temp.clear(); } while(!Stack2.empty()){ MoveNode = Stack2.top(); Stack2.pop(); if(MoveNode-&gt;left){ Stack1.push(MoveNode-&gt;left); Temp.push_back(MoveNode-&gt;left-&gt;val); } if(MoveNode-&gt;right){ Stack1.push(MoveNode-&gt;right); Temp.push_back(MoveNode-&gt;right-&gt;val); } } if(!Temp.empty()){ Result.push_back(Temp); Temp.clear(); } } return Result; } }; 题目描述2从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 思路:层次遍历 队列1. 定义一个队列和一个指针指向队列的头部2. 先把根存放在队列中3. 在队列不为空的条件下遍历4. 定义一个临时数组5. 出队列6. 把指针指向的值存放在临时数组中7. 找指针的左右子树，放入队列中8. 一层遍历完之后，把临时数组放入Result中9. 返回Result code2/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) { vector&lt;vector&lt;int&gt;&gt; Result; if(pRoot == NULL){ return Result; } TreeNode* MoveNode = NULL; queue&lt;TreeNode*&gt; queTree; queTree.push(pRoot); while(!queTree.empty()){ int size = queTree.size(); vector&lt;int&gt; temp; while(size--){ MoveNode = queTree.front(); queTree.pop(); temp.push_back(MoveNode-&gt;val); if(MoveNode-&gt;left!=NULL){ queTree.push(MoveNode-&gt;left); } if(MoveNode-&gt;right!=NULL){ queTree.push(MoveNode-&gt;right); } } Result.push_back(temp); } return Result; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"计算机网路——应用层","slug":"计算机网路——应用层","date":"2020-06-15T13:03:55.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/15/计算机网路——应用层/","link":"","permalink":"/2020/06/15/计算机网路——应用层/","excerpt":"","text":"计算机网络应用层 应用层DNS将域名解析成IP地址 查看解析的IP地址： ping www.baidu.com. nslookup www.baidu.com 域名解析过程他们其中都存在缓存，下一次直接访问 安装自己的DNS服务器·解析自己内网的域名·降低到Internet的解析域名流量·域环境 DHCPDHCP动态主机配置静态IP固定计算机或者服务器动态IP不固定计算机，防止网段冲突，DHCP统一分配动态IP地址，计算里自动获取IP或者自动获取DNS。 DHCP客户端请求IP 地址的过程 计算机A向外发广播，目标IP地址255.255.255.255，目标mac地址全F，交换机会传到所有的接口上去。2.DHCP收到广播请求之后，从自己的地址池里面选一个地址提供给客户机，假设有两个DHCP服务器给A提供地址。3.客户机此时再次发送一次确认要谁的地址，没有被选中的DHCP服务器就收回地址，被选中的服务器将IP地址，子网掩码、网关发送给客户机。 跨网段自动获取IP地址 这三个网段想在office1自动获取server-PT 分配的IP地址，只需要在office1路由器接口上ip helper-address 192.169.0.100之后计算机PC0 就能自动获取ip 地址192.169.1.1 这个地址是DHCP服务器分配的192.169.0.XX在这个网段只需要通过广播 DHCP：MAC——&gt;IP（广播）ARP：IP——&gt;MAC（广播） 文件传送协议 FTP 控制连接：标准端口是21数据连接：标准端口是20主动模式：服务器从20 端口主动向客户端发起连接（防火墙需要打开20 21 端口）被动模式：服务在指定某个范围内的某个端口被动等待客户端发起连接 TELNET 是一个简单的远程终端协议 23端口用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。(本地操作服务器，不安全) 远程桌面协议（RDP）远程桌面协议（RDP）GUI形式的mstsc3389 端口在服务器端把用户添加到远程桌面组 Remote Desktop UsersServer是多用户在本地把某个盘直接映射到远程服务器，可以直接执行拖动文件复制 端口 ip 地址 域名来区分不同的网页 Web 代理服务器访问网站1.节省内网访问Internet的带宽，当很多人都要访问Internet时，使用代理服务器，代理服务器会有缓存功能，在路由器上设置权限2.Web 代理可以绕过防火墙（VPN） 邮件传输协议当客户端发送邮件 时，首先通过SMTP协议到中继（某个邮件的邮局），然后再发送到另外一个邮件的邮局（这个过程有DNS解析），客户端通过POP 3协议从自己的邮局下载收到邮件公网IP 端口映射 网络安全数据存储安全应用程序安全操作系统安全网络安全物理安全 Conclusion协议一组规则OSI 7层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层 TCP/IP4层链路层：以太网帧协议，ARP网络层：IP&emsp;&emsp; ICMP &emsp;&emsp; IGMP传输层： TCP&emsp;&emsp; UDP应用层：HTTP&emsp;&emsp; FTP&emsp;&emsp; SSH &emsp;&emsp;Telnet 网络传输前需要封装 以太网帧协议ARP协议：根据IP地址获取MAC 地址以太网帧协议： 根据MAC地址完成数据包传输 IP 协议版本 :IPv6 IPv4 &emsp;&emsp; 4位TTL： 设置数据包在节点跳转的上限，下一跳。每次 减一，减到0丢弃源IP ： 32位目标IP： 32位 IP地址：在网络中 唯一标识一台 主机端口号：在一台主机 中，唯一标识一个进程IP+端口：网络环境中，唯一标识一个进程 UDP源端口号： 16位 &emsp;&emsp; 2^16 = 65536目标端口： 16位 IP协议源端口号： 16位 &emsp;&emsp; 2^16 = 65536目标端口： 16位32位序号32位确认序号6个标志位16位窗口 大小 B/S （移动）&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; C/S （PC ）优点：缓存大量数据、协议选择灵活、速度快&emsp;&emsp;&emsp; 安全性好、跨平台、工作量小缺点：安全性不好、跨平台弱、开发工作量大&emsp;&emsp;&emsp; 不能缓存大量数据、HTTP 协议 Socket套接字一个文件描述符指向一个套接字 （改套接字内部是由内核借助两个缓冲区实现的 ）通信过程中必须是成对出现的 网络字节序·小端法（pc 本地存储）&emsp;&emsp; 高位存高地址 &emsp;&emsp; 低位存低地址·大端法（网络存储） &emsp;&emsp; 高位存低地址 &emsp;&emsp; 低位存高地址Htonl 本地——&gt;网络（IP）Htons 本地——&gt;网络（port）Ntohl 网络——&gt;本地（IP）Ntohs 网络——&gt;本地（port） 例如192.168.2.12——&gt;string ——&gt;atoi——&gt;int ——&gt;htonl——&gt;网络字节序Int inet_pton(); 本地字节序（string IP）——&gt;网络字节序Const char *inet_ntop(); 网络字节序——&gt;本地字节序（string IP ） 借助TCP协议 实现C/S通信, 一共有3个套接字 Server：1.Socket() &emsp;&emsp; 创建socket2.Bind() &emsp;&emsp; 绑定服务器地址3.Listen() &emsp;&emsp; 设置监听上限4.Accept()&emsp;&emsp; 阻塞等待客户端连接5.Read() &emsp;&emsp; 读取scoket获取客户端数据6.小写转大写 &emsp;&emsp; toupper()7.Write()8.Close() Client:1.Socket() &emsp;&emsp; 创建socket2.Connect() &emsp;&emsp;与服务器连接3.Write() &emsp;&emsp; 写数据到socket4.Read() &emsp;&emsp; 读转换后的数据5.显示读取结果6.Close()","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"计算机网路——传输层","slug":"计算机网路——传输层","date":"2020-06-15T13:02:55.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/15/计算机网路——传输层/","link":"","permalink":"/2020/06/15/计算机网路——传输层/","excerpt":"","text":"计算机网络传输层 传输层两个协议TCP1.TCP（传输控制协议）：需要将要传输的文件分段，传输时建立会话，可靠传输，流量控制 TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。TCP 提供可靠交付的服务。TCP 提供全双工通信（同时收发）。面向字节流（文件以字节的形式传输）。 每一条 TCP 连接有两个端点。TCP 连接的端点叫做套接字(socket)或插口套接字 socket = (IP地址: 端口号)TCP 连接 :: = {socket1, socket2} = {(IP1: port1), (IP2: port2)} 停止等待协议 只要你没有告诉我你收到，我就认为你没有收到，我就要重发这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)。ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。 这种停止等待协议优点是简单，但缺点是信道利用率太低。 改进：流水线传输发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 连续 ARQ 协议发送方定义一个发送窗口，把窗口的数据包一起发送过去等待确认接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认。如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。 序号字段占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。确认号字段占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。数据偏移（即首部长度）占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。紧急 URG当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（在发送缓存中插队）(相当于高优先级的数据)。推送 PSH (PuSH) 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付（在接收端缓存中插队）。同步 SYN同步 SYN = 1 表示这是一个连接请求或连接接受报文。建立会话，伪造任意IP建立会话攻击某个计算机，让其计算机一直进行发送确认 ACK只有当 ACK =1 时确认号字段才有效。当 ACK = 0 时，确认号无效。复位 RST (ReSeT) 当 RST  1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。终止 FIN (FINis) 用来释放一个连接。FIN  1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。紧急指针字段占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）TCP滑动窗口技术实现可靠传输 当B确认收到6以后向A发送确认号7，此时A的中1——6就可以从缓存中删除，A的窗口向右滑动，B收到的给应用程序，窗口也向右滑动。假如发送过程中7——10 丢失了，通过选择性确认让发送端只发送丢包的数据7——10，后面的11——20 不用再发送一次。 TCP流量控制接后端告诉发送端，接受窗口（rwnd）是多少，发送端相应改变窗口（接收端处理不过来）TCP拥塞（所有计算机造成丢包 ）对资源需求的总和（所有计算请求150M） &gt; 可用资源（信道只能传100M）发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。 慢开始每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。慢开始门限（ssthresh）发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长 快重传和快恢复(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。快恢复算法(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。发送窗口的上限值= Min [rwnd, cwnd] TCP 的运输连接管理连接建立、数据传送和连接释放·TCP 连接的建立都是采用客户服务器方式。·主动发起连接建立的应用进程叫做客户(client)。·被动等待连接建立的应用进程叫做服务器(server)。 三次握手1.A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。2.B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x+1，自己选择的序号 seq = y。3.A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y+1。 A 的 TCP 通知上层应用进程，连接已经建立。（如果A发出请求需要建立连接，走了更远的路，需要的时间更长，A过一段时间之后发现B没有回应，再次发出请求，正常很快直接到了B，B也给出回应，一段时间之后，走远路的请求也到了B，此时B发现又有一个请求，再给A一个确认，这时A就不认B给出的确认，因为刚刚已经确认过了。B这时也会一直等A来传数据，A不搭理B，造成B资源浪费） 三次握手建立 TCP 连接的各状态 SYN-SENT：与不存在IP建立连接SYN-RCVD：SYN攻击，A使用假地址，请求B，B给出确认，A不搭理B 释放1.A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。2.B 发出确认，确认号 ack = u+ 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。3.A 收到连接释放报文段后，必须发出确认在确认报文段中 ACK = 1，确认号 ack =w+1，自己的序号 seq = u + 1。4.TCP 连接必须经过时间 2MSL 后才真正释放掉。(如果A确认的报文丢了，此时B在发送确认，A要是没有这两分钟，A就不会搭理B，B一直处于等待状态，关闭不了) TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。 新的 RTTS = (1 - α) (旧的 RTTS)+ α(新的 RTT 样本) UDP2.UDP（用户数据报协议）：一个数据报就能完成数据通信，不分段，不建立会话，不需要流量控制，不可靠传输 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。UDP 是无连接的，即发送数据之前不需要建立连接。UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。UDP 支持一对一、一对多、多对一和多对多的交互通信。UDP 的首部开销小，只有 8 个字节。 UDP首部 计算校验和在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部（网络层）仅仅是为了计算检验和。 当我们想要向DNS发送我们将要将域名解析成IP地址的时候，使用UDP协议。QQ聊天也使用UDP，QQ传文件TCP协议 。屏幕广播多播使用UDP。直接发送数据，如果失败了再发送一次查看会话 netstat -n 查看建立会话的进程 netstat -nb 传输层与应用层的关系传输层协议+端口号 HTTP = TCP+80HTTPS = TCP+443RDP（远程桌面）=TCP+3389FTP = TCP+21共享文件夹 = TCP+445SMTP（发送邮件） = TCP+25POP3（接受邮件） =TCP+110Telnet = TCP+23SQL = TCP+1433DNS = UDP+53 服务和应用层的关系·服务使用TCP或者UDP的端口侦听客户端的请求·客户端使用IP地址定位服务器，使用目标端口定位服务·可以在服务器网卡上设置只开放的必要端口，实现服务的网络安全在服务器端安装服务Web 服务 SMTP POP3 服务 netstat -an 查看服务侦听的端口 netstat -n 查看建立的会话 netstat -nb 查看建立会话的进程 telnet ip 端口号 测试远程计算机的某个端口是否打开 更改端口是为了是系统更安全迷惑别人误以为是默认的端口从而知道我们是什么服务设置Windows网卡安全（只开放某个服务的端口） 本地连接——属性——TCP/IP协议——属性——高级——选项 传输层功能为相互通信的应用进程提供逻辑服务（通过端口）端口号（0——65535）熟悉端口0——1023登记端口1023——49151客户端端口49152——65535传输层对收到的报文进行差错检测。传输层需要有两种不同的运输协议，即面向连接（建立会话）的 TCP 和无连接的 UDP","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"计算机网路——网络层","slug":"计算机网路——网络层","date":"2020-06-15T13:02:35.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/15/计算机网路——网络层/","link":"","permalink":"/2020/06/15/计算机网路——网络层/","excerpt":"","text":"计算机网络数据链路层 网络层负责在不同网络之间（路由器，不同网段）尽力转发数据包，基于数据包的IP地址（源地址——目标地址）不负责重传（数据丢失），不负责顺序（不同的数据包过来由路由器自己选择哪条路劲，负载均衡） 路由器工作在网络层交换机工作在数据链路层 一个路由器的一端网关都一样 （一般是..**.1）计算跨网段通信必须得配置网关路由器如何选择路径是由 路由决定的，可以通过管理员设置或者自己学习广播就是一个发给其他所有 网络设备和OSI参考模型关系计算机通信过程1.应用层 准备要传输的文件2.传输层 将文件分段并编号3.网络层 添加源IP地址和目标IP地址4.数据链路层 两种情况： 使用自己的子网掩码判断自己和目标地址在哪个网段，如果在同一网段，ARP协议广播解析目标IP的地址的MAC如果不在一个网段 ARP协议ARP协议将IP地址通过广播目标地址是FF-FF-FF-FF-FF-FF解析目标地址的MAC地址广播只能在同一网段广播，不能跨路由器第一次会使用ARP协议，之后就缓存MAC地址 arp -a 查看MAC地址arp欺骗：修改mac地址让其通信被某个mac控制网络执法官控制其他计算机通信arp -s 目标网关 自定义设定MAC （静态） ICMP协议用来测试网络层是否有故障，主要有ping 命令time &emsp;&emsp;延时 &emsp;&emsp; TTL：经过一个路由器TTL减一，防止数据包在网上有循环。ping &emsp;&emsp;ip &emsp;&emsp; -t &emsp;&emsp; 一直pingping &emsp; -l &emsp; 200 &emsp; ip &emsp; 指定发送数据包的大小200ping &emsp; ip &emsp; -i &emsp; 更改数据包TTL时间，能够跟踪数据包途径的路由器。请求超时是因为发送出去的数据不知道怎么回来pathping &emsp; ip &emsp; 跟踪数据包的路径，计算丢包情况tracert &emsp; ip &emsp; 跟踪数据包的路径 点到点 （一对一）广播（一对多）组播= 多播（多对多，跨网段，不建立会话，老师控制学生电脑一起上课） IGMP协议绑定在路由器上，在一个网段里扫描是否有在占用数据流，若果有，接受一份数据，没有就拒绝数据流 IP数据包一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。 版本占 4 bit(二进制数)，指 IP 协议的版本目前的 IP 协议版本号为 4 (即 IPv4) 首部长度占 4bit，由于存在变长部分所以首部长度是固定部分（20byte）+可变部分，一般就是20 区分服务谁的优先级高，让谁先行，给数据流加上标记，带标记的优先级高，gpedit.msc只有在使用区分服务（DiffServ）时，这个字段才起作用. 总长度占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。 标识（tag）由于数据链路层数据最大1500字节，此时需要将，ip数据包65535字节分片，分片后各自有自己的IP选择不同路径，接受段在网络层重组，如何重组？就使用标识，每个大的数据包有标记号，分片之后带上标记号的标识来重组数据包如果不分片，IP数据包不超过1480字节 标志(flag)占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF=1 表示后面“还有分片”。MF= 0 表示最后一个分片。标志字段中间的一位是 DF 只有当 DF=0 时才允许分片。 片偏移占12位，较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。 TTL（生存时间）——数据报在网络中可通过的路由器数的最大值。过一个路由器时间减一，减到一数据包就消失，防止路由中间出现环路。 协议占8位，字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程 协议号ICMP 1 &emsp; IGMP 2 &emsp; TCP 6 &emsp; UDP 17 &emsp;IPv6 41&emsp; OSPF 89 首部检验和占16位，字段只检验数据报的首部不检验数据部分。 IP 协议选择路由网络畅通的条件：数据包有去有回（必须得配网关）静态路由：管理员自己设定的查网关 查路由 Cisco Packet Tracer软件配置路由器局域网 n en config t interface fastEthernet 0/0 ip address 192.168.2.1 255.255.255.0 no sh Cisco Packet Tracer软件配置路由器广域网 exit interface serial 2/0 clock rate ? clock rate 64000 //时钟频率 只需要一个口定义时钟频率 ip address 172.165.5.1 255.255.255.0 no sh config t interface serial 3/0 no sh ip address 172.165.5.2 255.255.255.0 配置路由器网关（告诉路由器下一个路由是那个路由器） config t ip route 192.168.2.1 255.255.255.0 172.165.5.1 需要管理员告诉路由器所有没有直连的网络下一跳给谁适用于小规模网络，不能自动调整路由动态路由：自动学习（OSPF） RIP周期性广播路由表 30秒更新一次路由信息 选择路由器最小的数作为最佳路由，最大跳数 15跳启动RIP config t router rip network 192.168.0.1(路由器连接的网段) network 192.168.0.2 OSPF通过带宽选择路由ip&emsp; protocol &emsp; 查看是rip 还是OSPF","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"计算机网路——数据链路层","slug":"计算机网路——数据链路层","date":"2020-06-15T13:02:01.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/15/计算机网路——数据链路层/","link":"","permalink":"/2020/06/15/计算机网路——数据链路层/","excerpt":"","text":"计算机网络数据链路层 数据链路层信道数据链路层信道主要有以下两类: 点对点信道点对点信道。这种信道使用一对一的点对点通信方式。点对点协议也叫PPP协议1.简单2.封装成帧3.透明性4.多种网络层协议 （TCP/IP、SPX、IPX）5.多种类型链路6.差错检测7.检测连接状态8.最大传送单元9网络层地址协商10.数据压缩协商 不具备1.纠错2.流量控制3.序号4.多点线路5.半双工或单工链路 PPP 协议有三个组成部分 一个将 IP 数据报封装到串行链路的方法。链路控制协议 LCP (Link Control Protocol)，建立维护数据链路连接（相当于身份验证）。网络控制协议 NCP (Network Control Protocol)，接多种网络层协议。PPP协议帧格式PPP 有一个 2 个字节的协议字段。当协议字段为 0x0021 时，PPP 帧的信息字段就是IP 数据报。若为 0xC021, 则信息字段是 PPP 链路控制数据。若为 0x8021，则表示这是网络控制数据。 PPP透明问题1.将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。2.若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。3.只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除 广播信道这种信道使用一对多的广播通信方式，广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送（集线器和同轴线，没有交换机） CSMA/CD协议多点接入表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。随机时间计算算法叫做二进制指数类型退避算法 1.确定基本退避时间，一般是取为争用期 2τ。2.定义重传次数 k ，k … 10，即 k = Min[重传次数, 10]3.从整数集合[0,1,…, (2^k - 1)]中随机地取出一个数，记为 r。重传所需的时延就是 r*2τ4.当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 以太网就是这种方式，使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。 集线器是 CSMA/CD 协议，并共享逻辑上的总线，每台计算机平均分摊总线带宽。集线器很像一个多接口的转发器，只是一堆线，工作在物理层。 以太网的信道利用率a = τ/T0τ 与 T0 之比。在以太网中定义了参数 a,a→0 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。a 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。发送一帧占用线路的时间是 T0 + τ，而帧本身的发送时间是 T0。于是我们可计算出理想情况下的极限信道利用率 Smax为Smax=T0/(T0+τ)=1/(1+a) 以太网的 MAC 层使用Ethereal-setup 抓包工具可以查看具体数据帧 ###优化以太网（局域网）物理层：主机使用光纤和一对光纤调制解调器连接到集线器 （集线器链接的设备中，如果A和B通信，则其他的就不能通信，所有设备共享带宽，计算机数量增加，组件了一个更大的冲突域，造成效率低）在数据链路层扩展局域网使用网桥，后来就是交换机，端口带宽独享，有学习存储mac地址的能力2τ 叫做争用期争用期实际和网线长度有关以太网取 51.2μs 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突 数据链路层传送的是帧 三个基本问题(1)封装成帧首部和尾部的一个重要作用就是进行帧定界 (2)透明传输在数据帧中，中间出现了和帧为一样的部分，会丢弃一部分，此时使用透明传输解决此问题，填充转义字符 (3) 差错控制在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。使用循环冗余检验 CRC 的检错技术如果传输的数据是101001 在它后面加上n个0，除数位数为n+1，每次余数使用不进位加法，最终得到余数叫做帧检验序列（FCS），传输的时候数据加上FCS 101001 001。 接受的时候，用101001 001，除以发送的除数，若得出的余数 R = 0，则判定这个帧没有差错，就接受。若余数 R  0，则判定这个帧有差错，就丢弃。 除数位数越大，检验越准确，这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。只能做到无差错接受。 无差错接受，如果一样接受，不一样丢弃。","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"计算机网路——物理层","slug":"计算机网路——物理层","date":"2020-06-15T13:01:43.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/15/计算机网路——物理层/","link":"","permalink":"/2020/06/15/计算机网路——物理层/","excerpt":"","text":"计算机网络物理层 在浏览器输入URL时经历过程 ●应用层：所有能产生网络流量的应用程序●表示层：在传输之前是否进行加密或者压缩 （二进制、ASCLL）●会话层：查看传输过程中的木马 netstat -n, 是否存在其他病毒干扰传输●传输层：可靠传输，流量控制，不可靠传输（直接传输，客户端直接到达DNS传输）●网络层：负责选择最佳路径，规划IP地址（三次路由）●数据链路层：帧的开始和结束，透明传输，差错校验 （交换机二次）●物理层：接口标准，电器压标准，如何在物理链路上传输更快 网络排错1.先查看物理层故障：查看链接状态，发送和接收的数据包2.数据链路层故障：MAC地址冲突，ADSL欠费 网速没有协商配置一致，计算机链接到错误的VLAN3.网络层故障：配置错误的IP地址 子网掩码网关，路由配置没有配置到达目标网络的路由4.应用层故障：应用程序配置错误（浏览器） 网络安全1.物理层安全2.数据链路层安全 ADSL账号密码 VLAN交换机端口绑定MAC地址3.网络层安全 在路由器上使用ACL控制数据流量包4.应用层安全 开发的应用程序没有漏洞 计算机网络整体过程 速率：是以Bit来计算的 100M 100M bit/s 实际看到的是以字节为单位1 字节 = 8 bit发送时延 = 数据块长度/信道带宽 传播时延受介质影响（光纤或者铜）时延带宽积（信道信息量） = 传播时延* 带宽 物理层特性机械特性 ：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。电气特性 ：指明在接口电缆的各条线上出现的电压的范围。功能特性 ：指明某条线上出现的某一电平的电压表示何种意义。过程特性 ：指明对于不同功能的各种可能事件的出现顺序。 数据通信 信道码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。一个波形的高低电压 代表一个码元，一个码元可以携带n bit 的信息量 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 基带信号（即基本频带信号）——来自信源的信号。声音带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输 基带信号调制（基带——》带通信号） 常用的编码 信道的极限容量也就是噪声干扰奈氏准则：在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值香农公式：有信号干扰，信道的极限信息传输速率 C&emsp;&emsp;&emsp;&emsp;C = W log2(1+S/N) b/s信道的带宽（W无信号干扰）或信道中的信噪比（S/N）越大，则信息的极限传输速率就越高。只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 物理层传输媒体导向传输媒体双绞线屏蔽双绞线 STP (Shielded Twisted Pair)无屏蔽双绞线 UTP (Unshielded Twisted Pair)同轴电缆光缆光纤的工作原理网线：直通线：不同设备（主机到交换机）交叉线：同类设备（交换机到交换机） 非导向传输媒体无线传输所使用的频段很广。短波通信主要是靠电离层的反射，但短波信道的通信质量较差。微波在空间主要是直线传播。&emsp;&emsp;地面微波接力通信&emsp;&emsp;卫星通信集线器：同一时间只能两台计算机通信 信道复用技术1.频分复用2.时分复用时分复用可能会造成线路资源的浪费3.统计时分复用（加标记）4.码分复用有一个向量，我们能够分解成单位向量的加和，如果把三个坐标轴看作三种信号，当我们在传输一个向量的时候，就完美的传输了多个信号令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积都是 0任何一个码片向量和该码片向量自己的规格化内积都是1任何一个码片向量和该码片的反码的向量的规格化内积都是-1 数字传输系统使用脉码调制（PCM）在广域网之间传输 （E1 和T1 传输） 宽带接入技术1.ADSLDMT技术调制采用频分复用划分不均匀的频带&emsp;&emsp;ADSL组成 2.光纤同轴混合网HFC (Hybrid Fiber Coax)HFC网的主干线路采用光纤HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能每个家庭要安装一个用户接口盒&emsp;&emsp;·使用同轴电缆连接到机顶盒(set-top box)，然后再连接到用户的电视机。&emsp;&emsp;·使用双绞线连接到用户的电话机。&emsp;&emsp;·使用电缆调制解调器连接到用户的计算机。","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十八）","slug":"C-剑指offer刷题（四十八）","date":"2020-06-15T11:34:51.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/15/C-剑指offer刷题（四十八）/","link":"","permalink":"/2020/06/15/C-剑指offer刷题（四十八）/","excerpt":"","text":"题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路:特点1. 判断是否有右子树2. 有右子树：下个结点就是右子树最左边的点（D，B，E，A，C，G）3. 没有右子树：（1）这个节点是父节点左孩子（N，I，L）——父节点就是下一个节点 &emsp;&emsp;&emsp; &emsp;&emsp;（2）这个节点是父节点右孩子（H，J，K，M）——找他的父节点的父节点的父节点…直到找的这个节点是他父节点的左孩子位置，如果没有，比如M，那么他就是尾节点。 code/* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public: TreeLinkNode* GetNext(TreeLinkNode* pNode) { if(pNode == NULL){ return NULL; } //输入D 存在右孩子的时候，下一个节点就是找一直找左孩子 if(pNode-&gt;right != NULL){ pNode = pNode-&gt;right; while(pNode-&gt;left !=NULL){ pNode = pNode-&gt;left; } return pNode; } //没有右孩子找父节点，只要父节点不为空一直遍历 while(pNode-&gt;next !=NULL){ //定义一个父节点 TreeLinkNode* pRoot = pNode-&gt;next; //N是父节点的左孩子，返回父节点 if(pRoot-&gt;left == pNode){ return pRoot; } //.J是右孩子，一直找父节点的父节点 pNode = pNode-&gt;next; } //其他情况返回NULL return NULL; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十七）","slug":"C-剑指offer刷题（四十七）","date":"2020-06-14T05:12:57.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/14/C-剑指offer刷题（四十七）/","link":"","permalink":"/2020/06/14/C-剑指offer刷题（四十七）/","excerpt":"","text":"题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 思路:特点1. 定义三个指针分别指向头指正和NULL，2. 在当前指针不为空的条件下遍历3. 如果当前指针和指针指向的下一个相等，last 指向当前的下一个，否则，pre 指向当前指针，当前指针指向下一个4. 若果当前指针和指针指向的下一个相等，继续 向下遍历判断last的值和当前的指针任然一样，则last往后移动，知道不等于当前指针的值5. 若果当前指针和指针指向的下一个相等，last移动后的值已经不等于当前值了，此时我们要删除节点，如果当前指针指向头结点的话，我们要删除从头结点到last的下一个。如果 当前节点没有在头结点，我们删除pre的下一个到last的下一个6. 更新当前指针，指向last的下一个位置7. 返回此链表 code/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { ListNode* cur = pHead; ListNode* pre = NULL; ListNode* last = NULL; if(pHead == NULL){ return NULL; } if(pHead-&gt;next ==NULL){ return pHead; } while(cur!=NULL ){ if(cur-&gt;next!= NULL &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val){ last = cur-&gt;next; while(last!=NULL &amp;&amp; last-&gt;next!=NULL &amp;&amp; last-&gt;next-&gt;val == cur-&gt;val ){ last = last-&gt;next; } if(cur == pHead){ pHead = last-&gt;next; }else{ pre-&gt;next = last-&gt;next; } cur = last-&gt;next; }else{ pre = cur; cur = cur-&gt;next; } } return pHead; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十六）","slug":"C-剑指offer刷题（四十六）","date":"2020-06-14T05:12:48.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/14/C-剑指offer刷题（四十六）/","link":"","permalink":"/2020/06/14/C-剑指offer刷题（四十六）/","excerpt":"","text":"题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 思路:快慢指针1. 定义快慢指针（快指针一次走两步，慢指针一次走一步）2. 找第一次相遇点，一定相遇在环内3. 慢指针指向头指针4. 快慢指针一次走一步，如果相等则说明再次相遇点是环的入口5. 返回任意一个指针 code/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public: ListNode* EntryNodeOfLoop(ListNode* pHead) { if(pHead == NULL){ return NULL; } ListNode* fast = pHead; ListNode* slow = pHead; //相遇点 while(fast &amp;&amp; fast-&gt;next){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(slow == fast){ break; } } if(!fast || !fast-&gt;next){ return NULL; } slow = pHead; while(fast!=slow){ slow = slow-&gt;next; fast = fast-&gt;next; } return fast; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十五）","slug":"C-剑指offer刷题（四十五）","date":"2020-06-14T05:12:11.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/14/C-剑指offer刷题（四十五）/","link":"","permalink":"/2020/06/14/C-剑指offer刷题（四十五）/","excerpt":"","text":"题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。 思路:hash map1. 输入字符串存入vec 中，然后写出hash表2. 遍历hash表，返回表中的值为1的数 codeclass Solution { public: //Insert one char from stringstream string vec; char hash[255] = {0}; void Insert(char ch) { vec += ch; hash[ch]++; } //return the first appearence once char in current stringstream char FirstAppearingOnce() { for(int i =0;i&lt;vec.size();++i){ if(hash[vec[i]]==1){ return vec[i]; } } return &#39;#&#39;; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十四）","slug":"C-剑指offer刷题（四十四）","date":"2020-06-08T13:38:25.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/08/C-剑指offer刷题（四十四）/","link":"","permalink":"/2020/06/08/C-剑指offer刷题（四十四）/","excerpt":"","text":"题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 思路:特点1. +-152. + || -3. 两个 . . false4. e10(e前面没有数) 1e12e（e前面已经有一个e）5. e +6. e + -7. e后面没有数 codeclass Solution { public: bool isNumeric(char* string) { //e 后面没有数字 //有其他字符 //两个小数点 //+-连续 //e后面有小数点 if(string == NULL){ return false; } if(*string == &#39;+&#39; || *string == &#39;-&#39;){ string++; //+- 15 if(*string == &#39;+&#39; || *string == &#39;-&#39;){ return false; } //+ || - if(*string = &#39;\\0&#39;){ return false; } } int decimal = 0,e = 0,number = 0; while(*string != &#39;\\0&#39;){ if(*string &gt;= &#39;0&#39; &amp;&amp; *string&lt;= &#39;9&#39;){ string++; number++; }else if(*string == &#39;.&#39;){ // 两个小数点 .. 不行 //e后面有.不行 if(decimal&gt;0 || e &gt;0){ return false; } string++; decimal++; }else if(*string == &#39;e&#39; || *string == &#39;E&#39;){ //e10(e前面没有数) 1e12e（e前面已经有一个e） if(number == 0 || e&gt; 0){ return false; } string++; e++; //e+ if(*string == &#39;+&#39; || *string == &#39;-&#39;){ string++; //e+ + if(*string == &#39;+&#39; || *string == &#39;-&#39;){ return false; } } //e后面没有数 if(*string == &#39;\\0&#39;){ return false; } }else{ return false; } } return true; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十三）","slug":"C-剑指offer刷题（四十三）","date":"2020-06-08T13:38:00.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/08/C-剑指offer刷题（四十三）/","link":"","permalink":"/2020/06/08/C-剑指offer刷题（四十三）/","excerpt":"","text":"题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 思路:递归B[i] == A[0] A[1] A[2] A[i-1] … A[i+1]… A[n-1]1. str 和pattern都为空2. str不为空 pattern为空3. 都不为空&emsp;&emsp;&emsp;(1).（aaa&emsp;&emsp;a.a;aaa&emsp;&emsp;.aa ）pattern+1不是为，第一个相同继续比较下一个；str不为空，pattern为.继续比较下一个&emsp;&emsp;&emsp;(2).（aa&emsp;&emsp;aaa;aaa&emsp;&emsp;.a ）pattern+1为,第一个相同继续比较下一个pattern跳过两个；str不为空，pattern为.str向下移动;否则（aa&emsp;&emsp;c*aa）pattern跳过两个 codeclass Solution { public: bool match(char* str, char* pattern) { if(*str ==&#39;\\0&#39; &amp;&amp; *pattern == &#39;\\0&#39;){ return true; } if(*str !=&#39;\\0&#39; &amp;&amp; *pattern == &#39;\\0&#39;){ return false; } //都不为空 if(*(pattern+1) != &#39;*&#39;){ //aaa a.a aaa .aa if(*str == *pattern || (*str != &#39;\\0&#39;)&amp;&amp; *pattern == &#39;.&#39;){ return match(str+1,pattern+1); }else{ return false; } }else{ if(*str == *pattern || (*str != &#39;\\0&#39;)&amp;&amp; *pattern == &#39;.&#39;){ return match(str,pattern+2) || match(str+1,pattern); //aa a*aa //aaa .*a 只需要看str 是否相同，.* *可以为n个 }else{ // aa c*aa return match(str,pattern+2); } } } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十二）","slug":"C-剑指offer刷题（四十二）","date":"2020-06-08T13:35:42.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/08/C-剑指offer刷题（四十二）/","link":"","permalink":"/2020/06/08/C-剑指offer刷题（四十二）/","excerpt":"","text":"题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。（注意：规定B[0] = A[1] A[2] … A[n-1]，B[n-1] = A[0] A[1] … A[n-2];） 思路:规律B[i] == A[0] A[1] A[2] A[i-1] … A[i+1]… A[n-1]1. 找出前半部分2. 找出后半部分 codeclass Solution { public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) { int n = A.size(); vector&lt;int&gt; B(n); int ret = 1; //B[i] == A[0] A[1] A[2] A[i-1] ... A[i+1]... A[n-1] //前半部分 for(int i = 0;i&lt; n; ret*= A[i++]){ B[i] = ret; } ret = 1; //后半部分 for(int i = n-1;i&gt;=0;ret*= A[i--]){ B[i] *= ret; } return B; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十一）","slug":"C-剑指offer刷题（四十一）","date":"2020-06-06T03:34:34.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/06/C-剑指offer刷题（四十一）/","link":"","permalink":"/2020/06/06/C-剑指offer刷题（四十一）/","excerpt":"","text":"题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路:hash map1. 把数组存放到hasp 表中2. 拿出次数大于1 的数 codeclass Solution { public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) { if(numbers== NULL || length ==0){ return 0; } //hash map int hashTable[255] = {0}; for(int i= 0;i&lt;length;++i){ hashTable[numbers[i]]++; } int count = 0; for(int i = 0 ;i&lt;length;++i){ if(hashTable[numbers[i]]&gt;1){ duplication[count++]=numbers[i]; return true; } } return false; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四十）","slug":"C-剑指offer刷题（四十）","date":"2020-06-05T08:54:35.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/06/05/C-剑指offer刷题（四十）/","link":"","permalink":"/2020/06/05/C-剑指offer刷题（四十）/","excerpt":"","text":"题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 思路:约瑟夫环直接return （（递归 删除一个小朋友） +m）%n code1class Solution { public: int LastRemaining_Solution(int n, int m) { if(n&lt;=0){ return -1; } return (LastRemaining_Solution(n-1,m)+m)%n; } }; 题目描述2求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 思路:判断条件转化&amp; code2class Solution { public: int Sum_Solution(int n) { int result = n; (n&gt;0) &amp;&amp; (result += Sum_Solution(n-1)); return result; } }; 题目描述3写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 思路:异或^1. 两个数取异或（相同为0，不相同为1）特性就是不进位的加法2. 两个数取&amp;左移1位确定进位数3. num1 = num1^num24. num2 = (num1&amp;num2)&lt;&lt;1;5. 进位为0结束 code3class Solution { public: int Add(int num1, int num2) { int sum,carryLShift; while(num2!=0){ sum = num1^num2; carryLShift = (num1&amp;num2)&lt;&lt;1; num1 = sum; num2 = carryLShift; } return num1; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十九）","slug":"C-剑指offer刷题（三十九）","date":"2020-05-29T02:12:44.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/29/C-剑指offer刷题（三十九）/","link":"","permalink":"/2020/05/29/C-剑指offer刷题（三十九）/","excerpt":"","text":"题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 思路:顺子1. 统计0的个数2. 统计间隙数3. 如果0的个数大于等于间隙数，0可以填充在他们之间构成顺子，否则return false。 codeclass Solution { public: bool IsContinuous( vector&lt;int&gt; numbers ) { if(numbers.size()&lt;5){ return false; } sort(numbers.begin(),numbers.end()); int NumOfZero = 0, SpaceCount = 0; //统计0的个数 for(int i = 0;i&lt;numbers.size();++i ){ if(numbers[i]== 0)NumOfZero++; } //统计间隙数 for(int j = NumOfZero+1;j&lt;numbers.size();j++){ if(numbers[j]==numbers[j-1])return false; else{ SpaceCount+= numbers[j]-numbers[j-1] -1; } } if(NumOfZero &gt;= SpaceCount){ return true; }else{ return false; } } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十八）","slug":"C-剑指offer刷题（三十八）","date":"2020-05-28T14:07:39.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/28/C-剑指offer刷题（三十八）/","link":"","permalink":"/2020/05/28/C-剑指offer刷题（三十八）/","excerpt":"","text":"题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路:字符串拼接1. 定义一个临时数组存放一个单词2. 遇到空格就把该单词存放在result中（注意拼接顺序）3. 确定最后一个单词，拼接在result中 codeclass Solution { public: string ReverseSentence(string str) { string result = &quot;&quot;; string tempArray = &quot;&quot;; for(int i = 0;i&lt;str.size();++i){ if(str[i]== &#39; &#39; ){ result = &quot; &quot; + tempArray + result; tempArray = &quot;&quot;; }else{ tempArray+=str[i]; } } if(tempArray.size()){ result = tempArray + result; } return result; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十七）","slug":"C-剑指offer刷题（三十七）","date":"2020-05-27T13:12:36.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/27/C-剑指offer刷题（三十七）/","link":"","permalink":"/2020/05/27/C-剑指offer刷题（三十七）/","excerpt":"","text":"题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 思路:截取字符串1. 拿出前n位2. 删除前n位3. 拿出的前n位放到str之后 codeclass Solution { public: string LeftRotateString(string str, int n) { /* //截取前n位插入字符串的后面 string tempStr=&quot;&quot;; if(n&lt;0){ return NULL; } if(n==0){ return str; } tempStr = str.substr(0,n); //从第0 位开始截取str的n-1 个数 str.erase(0,n); str+=tempStr; return str; */ if(n&lt;0){ return NULL; } if(n==0){ return str; } string tempStr = &quot;&quot;; for(int i = n;i&lt;str.size();++i){ tempStr.push_back(str[i]); } for(int i = 0;i&lt;n;++i){ tempStr.push_back(str[i]); } return tempStr; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十六）","slug":"C-剑指offer刷题（三十六）","date":"2020-05-27T12:10:21.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/27/C-剑指offer刷题（三十六）/","link":"","permalink":"/2020/05/27/C-剑指offer刷题（三十六）/","excerpt":"","text":"题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 思路:大小指针移动1. 在两个指针内等差数列求和2. 如果和比输入数小，大指针向后移（先加上大的）3. 相等的话依次将数插入数组中4. 再把数组序列插入结果中，小指针继续加加，向后找5. 如果和比输入数大，小指针向后移（先减去小的） codeclass Solution { public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) { vector&lt;vector&lt;int&gt; &gt;result; int small=1,big=2; while(small&lt;big){ int cur=(small+big)*(big-small+1)/2; if(cur&lt;sum) big++; else if(cur==sum){ vector&lt;int&gt; temp; for(int i=small;i&lt;=big;i++){ temp.push_back(i); } result.push_back(temp); small++; } else small++; } return result; } }; 题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。对应每个测试案例，输出两个数，小的先输出。 思路:头尾指针移动实际上排序好的数列里，相差越远，他们乘积也就越小，头尾指针相差最远，依次缩小找到满足条件的就是最小的1. 在头尾指针里面2. 如果相等，直接把头尾指针放到数组中输出3. 如果比输入值小，头指针向后移动4. 如果比输入值大，尾指针向前移动 codeclass Solution { public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) { vector&lt;int&gt; result; if(array.size() == 0 ){ return result; } int leftP = 0; int rightP = array.size()-1; while(leftP &lt; rightP){ int toltal = array[leftP]+array[rightP]; if(toltal == sum){ result.push_back(array[leftP]); result.push_back(array[rightP]); break; }else if(toltal &lt; sum){ ++leftP; }else{ --rightP; } } return result; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十五）","slug":"C-剑指offer刷题（三十五）","date":"2020-05-25T04:56:40.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/25/C-剑指offer刷题（三十五）/","link":"","permalink":"/2020/05/25/C-剑指offer刷题（三十五）/","excerpt":"","text":"题目描述一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 思路1:异或···异或 相同为0， 不相同为1···a ^ a = 0···a^0 = a···满足结合律1. 求出num1 ^ num22. 统计移位次数3. 分组再异或找出各组的那一个值 code1class Solution { public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) { if(data.size() == 0){ return; } //求num1 ^ num2 int XorResult = 0; for(auto x: data){ XorResult ^= x; } //统计移位次数 int SiftCount = 0; while((XorResult&amp;1)==0){ XorResult = XorResult&gt;&gt;1; ++SiftCount; } //分组 for(auto x:data){ if(((x&gt;&gt;SiftCount)&amp;1) == 1){ *num1 ^= x; }else{ *num2 ^= x; } } return; } }; 思路2:hash map 1. 遍历统计出现的次数2. 定义vector存放只出现一次的数3. 写出求的数 code2class Solution { public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) { //使用Map unordered_map&lt;int,int&gt; hash; for(auto x: data) hash[x]++; vector&lt;int&gt; temp;//存放num1 和 num2 for(auto x:data){ if(hash[x] ==1){ temp.push_back(x); } } *num1 = temp[0]; *num2 = temp[1]; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十四）","slug":"C-剑指offer刷题（三十四）","date":"2020-05-24T06:05:50.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/24/C-剑指offer刷题（三十四）/","link":"","permalink":"/2020/05/24/C-剑指offer刷题（三十四）/","excerpt":"","text":"题目描述1输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路:递归1. 递归遍历左子树2. 递归遍历右子树3. 返回最大值加一 code1/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: int TreeDepth(TreeNode* pRoot) { if(pRoot == NULL) return 0; return max(TreeDepth(pRoot-&gt;left),TreeDepth(pRoot-&gt;right))+1; } }; 题目描述2输入一棵二叉树，判断该二叉树是否是平衡二叉树。在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 平衡二叉树又称AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 思路:递归1. 找出左右子树的深度2. 判断深度差是否小于1 code2class Solution { public: bool status = true; bool IsBalanced_Solution(TreeNode* pRoot) { GetDeep(pRoot); return status; } int GetDeep(TreeNode* pRoot){ if(pRoot == NULL){ return 0; } int leftDeep = GetDeep(pRoot-&gt;left); int rightDeep = GetDeep(pRoot-&gt;right); if(abs(leftDeep-rightDeep)&gt;1){ status = false; } return max(leftDeep,rightDeep)+1; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十三）","slug":"C-剑指offer刷题（三十三）","date":"2020-05-23T05:13:14.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/23/C-剑指offer刷题（三十三）/","link":"","permalink":"/2020/05/23/C-剑指offer刷题（三十三）/","excerpt":"","text":"题目描述统计一个数字在排序数组中出现的次数。 思路:二分法1. 将数组二分2. 二分直到 找到和k 相同的位置3. 相同位置 往前找相同数4. 相同位置 往后找相同数5. 返回计数 codeclass Solution { public: int GetNumberOfK(vector&lt;int&gt; data ,int k) { //二分法找中间 int Len = data.size(); if(Len ==0){ return 0; } int start = 0,mid = 0,end = Len-1,count=0; //二分直到 找到和k 相同的位置 while(start &lt; end){ mid = (end + start)&gt;&gt;1; if(k&lt;data[mid]){ end = mid-1; } if(k&gt;data[mid]){ start = mid+1; } if(k == data[mid]){ break; } } //相同位置 往前找相同数 int i = mid; while(i&gt;=0 &amp;&amp; k==data[i]){ --i; ++count; } //相同位置 往后找相同数 i = mid+1; while(i&lt;Len &amp;&amp; k==data[i]){ ++i; ++count; } return count; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十二）","slug":"C-剑指offer刷题（三十二）","date":"2020-05-23T05:13:08.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/23/C-剑指offer刷题（三十二）/","link":"","permalink":"/2020/05/23/C-剑指offer刷题（三十二）/","excerpt":"","text":"题目描述输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 思路:指针扫描1. 定义两个指针分别指向两个链表2. 在p1 != p2 条件下2. p1 指向空的时候，让他指向pHead23. p2 指向空的时候，让他指向pHead1，p1 ！= p2 p1继续往下指，直到指向空4. 两个指针分别向后指5. 返回p1 code/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) { if(pHead1== NULL || pHead2 == NULL){ return NULL; } ListNode *p1 = pHead1; ListNode *p2 = pHead2; while(p1!=p2){ //p1 指向空的时候，让他指向pHead2 p1 = (p1 == NULL ? pHead2 : p1-&gt;next ); //p2 指向空的时候，让他指向pHead1，p1 ！= p2 p1继续往下指，直到指向空 p2 = (p2 == NULL ? pHead1 : p2-&gt;next ); } return p1; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十一）","slug":"C-剑指offer刷题（三十一）","date":"2020-05-23T05:12:49.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/23/C-剑指offer刷题（三十一）/","link":"","permalink":"/2020/05/23/C-剑指offer刷题（三十一）/","excerpt":"","text":"题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 归并排序其实就是分治合并 思路:归并排序1. 分治（分成左右两边相等的两个数组，递归继续划分，直到只剩下数组只有 1个元素）2. 合并排序，定义一个临时数组存放排序后的结果（在合并的过程中就能找出逆序对）3. 主要是找 左边和右边 断开的逆序对&emsp;&emsp;若果此时i 的值比j的值小，他们之间不构成逆序对，把最小的值放入临时数组中，并且指向i 的指针向后移动继续比较&emsp;&emsp;若果发现此时i 的值比j 的值大，他们构成逆序对，并且他们之间有 （mid - i + 1）对4. 判断前半部分5. 判断后半部分6. 排序好的覆盖原来的 codeclass Solution { public: int count; int InversePairs(vector&lt;int&gt; nums) { if(nums.size()!=0){ //分治 划分整个数组 divide(nums ,0,nums.size()-1); } return count; } //分治思路 void divide(vector&lt;int&gt; &amp;nums,int start,int end){ if(start &gt;= end) return; //取中间值 int mid = start + (end-start)/2; //递归左右两边数组 divide(nums,start,mid); divide(nums,mid+1,end); //合并排序 merge(nums,start,mid,end); } //合并 void merge(vector&lt;int&gt; &amp;nums,int start ,int mid, int end){ //定义临时数组 vector&lt;int&gt; temp; int i = start , j = mid+1,k = 0; //比较左右两边间隙，中间存在逆序对 【start....i.....mid】【mid+1.....j.....end】 while(i&lt;=mid &amp;&amp; j&lt;=end){ //若果此时i 的值比j的值小，他们之间不构成逆序对，把 最小的值放入临时数组中，并且指向i 的指针向后移动继续比较 if(nums[i] &lt;= nums[j]){ temp.push_back(nums[i++]); }else{ //若果发现此时i 的值比j 的值大，他们构成逆序对，并且他们之间有 （mid - i + 1）对 temp.push_back(nums[j++]); count = (count + mid-i+1)%1000000007; } } //判断前半部分 while(i&lt;=mid){ temp.push_back(nums[i++]); } //判断后半部分 while(j&lt;=end){ temp.push_back(nums[j++]); } //排序好的覆盖原来的 for(k;k&lt;temp.size();++k){ nums[start+k] = temp[k]; } } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三十）","slug":"C-剑指offer刷题（三十）","date":"2020-05-21T01:28:09.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/21/C-剑指offer刷题（三十）/","link":"","permalink":"/2020/05/21/C-剑指offer刷题（三十）/","excerpt":"","text":"题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数） 思路:hash map1. 定义一个hash表 unordered_map&lt;char,int&gt; hash2. 遍历统计每个字符出现的次数3. 遍历出满足出现的次数 codeclass Solution { public: int FirstNotRepeatingChar(string str) { if(str.size() == 0) return -1; //遍历统计每个字符出现的次数 unordered_map&lt;char,int&gt; hash; for(auto x : str){ ++hash[x]; } //遍历出现的次数 for(int i = 0;i&lt;str.length();++i){ if(hash[str[i]] == 1){ return i; } } return -1; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十九）","slug":"C-剑指offer刷题（二十九）","date":"2020-05-20T12:02:21.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/20/C-剑指offer刷题（二十九）/","link":"","permalink":"/2020/05/20/C-剑指offer刷题（二十九）/","excerpt":"","text":"题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路:1. 定义一个丑数数组2. 定义三个数分别指向乘以2、3、5的虚队列3. 找到分别乘以2,3,5的虚拟队列的最小值4. 如果最小值与乘以2,3,5中P指向相等，则把P指向的数插入到丑数数组中，并且指向往后移5. 返回丑数数组最后一个数 codeclass Solution { public: int GetUglyNumber_Solution(int index) { if (index &lt;= 0){ return 0; } if(index &lt; 7){ return index; } vector&lt;int&gt; UglyResult; int P2= 0,P3 = 0,P5 = 0; int MinUgly = 1; UglyResult.push_back(MinUgly); while(UglyResult.size() &lt; index){ MinUgly = min(UglyResult[P2]*2,min(UglyResult[P3]*3,UglyResult[P5]*5)); if(UglyResult[P2]*2 == MinUgly) ++P2; if(UglyResult[P3]*3 == MinUgly) ++P3; if(UglyResult[P5]*5 == MinUgly) ++P5; UglyResult.push_back(MinUgly); } return UglyResult.back(); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十八）","slug":"C-剑指offer刷题（二十八）","date":"2020-05-18T06:11:03.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/18/C-剑指offer刷题（二十八）/","link":"","permalink":"/2020/05/18/C-剑指offer刷题（二十八）/","excerpt":"","text":"题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 思路:数组转字符串1. a + b &lt; b + a 则 a 排在前面2. 利用sort排序，排序方式按照camp 排序2. 输出字符串 codeclass Solution { public: static bool camp(int a, int b){ string a_s = to_string(a); string b_s = to_string(b); return a_s + b_s &lt; b_s + a_s; } string PrintMinNumber(vector&lt;int&gt; numbers) { string result; sort(numbers.begin(),numbers.end(),camp); for(auto x :numbers){ result += to_string(x); } return result; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十七）","slug":"C-剑指offer刷题（二十七）","date":"2020-05-15T01:40:50.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/15/C-剑指offer刷题（二十七）/","link":"","permalink":"/2020/05/15/C-剑指offer刷题（二十七）/","excerpt":"","text":"题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 思路:规律1. 找出当前位、高位、低位2. 判断当前位是0、1、大于13. 遍历个十百千位… codeclass Solution { public: int NumberOf1Between1AndN_Solution(int n) { if( n&lt;=0 ){ return 0; } int count = 0; int digit = 1; //个十百千..1.10 100 1000 while(n/digit!=0){ int CurNum = (n/digit)%10; //数字的当前个十百千位 int HightNum = n/(digit*10); //当前位前面的数字 int LowNum = n % digit; //当前位后面的数字 if(CurNum == 0){ count += HightNum * digit; }else if(CurNum == 1){ count += HightNum*digit + LowNum +1; }else{ count += digit*(HightNum +1); } digit *= 10; } return count; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十六）","slug":"C-剑指offer刷题（二十六）","date":"2020-05-13T13:15:05.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/13/C-剑指offer刷题（二十六）/","link":"","permalink":"/2020/05/13/C-剑指offer刷题（二十六）/","excerpt":"","text":"题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 思路:动态规划注意：1. vector F_i(array.size()) &emsp; &emsp;//分配大小2. return *max_element(F_i.begin(),F_i.end()); &emsp; &emsp;//返回vector最大值 codeclass Solution { public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) { if(array.empty()){ return 0; } vector&lt;int&gt; F_i(array.size()); F_i[0] = array[0]; for(int i =1; i &lt; array.size(); ++i){ if(F_i[i-1]&lt;=0){ F_i[i] = array[i]; }else{ F_i[i] = F_i[i-1]+array[i]; } } return *max_element(F_i.begin(),F_i.end()); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十五）","slug":"C-剑指offer刷题（二十五）","date":"2020-05-12T12:10:59.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/12/C-剑指offer刷题（二十五）/","link":"","permalink":"/2020/05/12/C-剑指offer刷题（二十五）/","excerpt":"","text":"输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 思路：sort排序1. sort排序2. 前k个就是最小 codeclass Solution { public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) { vector&lt;int&gt; MinResult; int size = input.size(); if(input.empty()||k&gt;size){ return MinResult; } sort(input.begin(),input.end()); for(int i = 0;i&lt;k;++i){ MinResult.push_back(input[i]); } return MinResult; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十四）","slug":"C-剑指offer刷题（二十四）","date":"2020-05-11T04:30:08.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/11/C-剑指offer刷题（二十四）/","link":"","permalink":"/2020/05/11/C-剑指offer刷题（二十四）/","excerpt":"","text":"题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路1：sort排序1. 找数（中间的值即为所求）2. 遍历计算计数3. 判断是否满足条件 code1class Solution { public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) { if(numbers.empty()){ return 0; } //排序 如果满足条件，中间的值即为所求 sort(numbers.begin(),numbers.end()); int numSize = numbers.size(); int halfNumSize = numSize &gt;&gt; 1; int middle = numbers[halfNumSize]; //遍历计算计数 int count = 0; for(auto x : numbers){ if(middle == x){ ++count; } } return (count &gt; halfNumSize) ? middle : 0; } }; 思路2：数组规律1. 找数（如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多）&emsp;&emsp;&emsp;1.当前值与遍历值比较，如果相等计数加一&emsp;&emsp;&emsp;2.不相等&emsp;&emsp;&emsp;&emsp;&emsp;（1）判断count是否大于0&emsp;&emsp;&emsp;&emsp;&emsp;（2）count大于0， - -count&emsp;&emsp;&emsp;&emsp;&emsp;（2）count小于等于0 count置1并且当前值改为遍历值2. 重新计算count的值3. 判断是否满足条件 code2class Solution { public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) { if(numbers.empty()){ return 0; } int curVal,count = 0; int numSize = numbers.size(); int halfNumSize = numSize &gt;&gt; 1; //int boundary = numSize &gt;&gt; 1; //作用就是迭代容器中所有的元素，每一个元素的临时名字就是x，等同于 //for (vector&lt;int&gt;::iterator iter = nums.begin(); iter != nums.end(); iter++) //找出这个数字(如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多) for(auto x : numbers){ //如果相等计数加一 if(curVal == x){ ++count; }else{ //不相等继续判断，如果count不等于0，计数减一 if(count&gt;0){ --count; }else{//如果等于0 ，curVal当前值存放下一个值，并且把count置1 curVal=x; count=1; } } } //重新计算count的值，来判断是否满则条件 for(auto x : numbers){ if(curVal == x){ ++count; } } return (count &gt; halfNumSize) ? curVal : 0; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十三）","slug":"C-剑指offer刷题（二十三）","date":"2020-05-08T02:06:35.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/08/C-剑指offer刷题（二十三）/","link":"","permalink":"/2020/05/08/C-剑指offer刷题（二十三）/","excerpt":"","text":"##题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 思路：递归1. 全排列&emsp;&emsp;（1）检查输出的字符串长度是否等于输入长度&emsp;&emsp;（2）如果相等使用find 函数判断是否存在重复的，添加不重复的&emsp;&emsp;&emsp;&emsp;find(result.begin(),result.end(),str) == result.end()&emsp;&emsp;&emsp;&emsp;&emsp;返回的是指针&emsp;&emsp;&emsp;&emsp;&emsp;如果在查找范围内不存在，返回result.end()&emsp;&emsp;（3）固定位置，字符依次同后面字符交换&emsp;&emsp;（4）递归后面字符的排列&emsp;&emsp;（5）还原交换前的状态2. 结果按字典排序 codeclass Solution { public: //(1) 遍历出所有可能出现在第一个位置的字符 //(2) 固定第一个字符，求后面字符的排列 vector&lt;string&gt; Permutation(string str) { vector&lt;string&gt; result; if(str.empty()){ return result; } //全排列 Permutation(str,result,0); //结果按字典排序 sort(result.begin(),result.end()); return result; } void Permutation(string str,vector&lt;string&gt; &amp;result,int state){ //结束条件，输出的字符串长度==输入的字符串长度 if(state == str.size()-1){ //find 返回的是指针 // 如果在查找范围内不存在，返回a.end() //如果result中不存在str，才添加；避免重复添加的情况 if(find(result.begin(),result.end(),str) == result.end()){ result.push_back(str); } }else{ for(int i= state;i&lt;str.size();i++){ //state 用来固定位置,第一个字符同后面所有字符交换 swap(str[i],str[state]); //后面字符的排列——递归 Permutation(str,result,state+1); //还原交换前的状态 swap(str[i],str[state]); } } } void swap(char &amp;str1 ,char &amp;str2){ char temp ; temp = str1; str1 = str2; str2 = temp; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十二）","slug":"C-剑指offer刷题（二十二）","date":"2020-05-06T11:33:18.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/06/C-剑指offer刷题（二十二）/","link":"","permalink":"/2020/05/06/C-剑指offer刷题（二十二）/","excerpt":"","text":"题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路：二叉树指针操作（中序遍历）1. 定义一个栈；定义一个指针pre记录上一次出栈值2. 遍历左子树放入栈中3. 取出栈顶元素就是最小值也是链表头结点4. 出栈，第一次出栈，前一次指针pre为空；如果不为空穿线，pre后继直线当前位置，当前位置的前继指向pre的位置5. pre指向当前位置6. 继续遍历右子树 code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: TreeNode* Convert(TreeNode* pRootOfTree) { if(pRootOfTree == NULL){ return NULL; } TreeNode *head = NULL; TreeNode *pre = NULL; stack&lt;TreeNode*&gt; tempStack; while(pRootOfTree || !tempStack.empty()){ //找到左子树的最小值并依次压栈 while(pRootOfTree){ tempStack.push(pRootOfTree); pRootOfTree = pRootOfTree-&gt;left; } //当前指针指向最小值 if(!tempStack.empty()){ pRootOfTree = tempStack.top(); tempStack.pop(); if(pre != NULL){ //pre的后继指向当前（最开始指向最小值） pre-&gt;right = pRootOfTree; //当前的前继指向pre pRootOfTree-&gt;left = pre; }else{ //返回头结点 head = pRootOfTree; } //pre向后移动 pre = pRootOfTree; //找是否存在右子树 pRootOfTree = pRootOfTree-&gt;right; } } return head; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C-剑指offer刷题（二十一）","slug":"C-剑指offer刷题（二十一）","date":"2020-05-05T03:57:10.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/05/C-剑指offer刷题（二十一）/","link":"","permalink":"/2020/05/05/C-剑指offer刷题（二十一）/","excerpt":"","text":"题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空 思路：链表指针操作1. 复制一个与前一个值相同的结点2. 穿线链接成一个新的链表3. 设置新链表的随机指针作用域 pClone-&gt;random =pNode-&gt;random-&gt;next;4. 指向新链表的第二个结点即拷贝好的链表的头结点5. 穿线操作拆分成两个链表（复制和被复制） code/* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { } }; */ class Solution { public: RandomListNode* Clone(RandomListNode* pHead) { if(pHead == NULL){ return NULL; } //复制链表节点并连线 CloneNodeConnect(pHead); //新结点设置随机指针 SetNodeRandom(pHead); //把链表从新拆分成两个链表 return ReConnect(pHead); } void CloneNodeConnect(RandomListNode* Head){ RandomListNode *pNode = Head; while(pNode != NULL){ RandomListNode *pClone = new RandomListNode(pNode-&gt;label); pClone-&gt;next = pNode-&gt;next; pNode-&gt;next = pClone; pNode = pClone-&gt;next; } } void SetNodeRandom(RandomListNode* Head){ RandomListNode *pNode = Head; while(pNode != NULL){ RandomListNode *pClone = pNode-&gt;next; if(pNode-&gt;random){ pClone-&gt;random =pNode-&gt;random-&gt;next; } pNode = pClone-&gt;next; } } RandomListNode* ReConnect(RandomListNode* Head){ RandomListNode* pNode = Head; //返回头结点 RandomListNode* pCloned = Head-&gt;next; while(pNode != NULL){ RandomListNode* pClone = pNode-&gt;next; //重连原链表 pNode-&gt;next = pClone-&gt;next; pNode = pNode-&gt;next; if(pNode != NULL){ //重连新链表 pClone-&gt;next = pNode-&gt;next; } } return pCloned; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（二十）","slug":"C-剑指offer刷题（二十）","date":"2020-05-02T09:18:04.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/02/C-剑指offer刷题（二十）/","link":"","permalink":"/2020/05/02/C-剑指offer刷题（二十）/","excerpt":"","text":"题目描述输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 思路：先序遍历、递归1. 定义一个临时数组存储路径 ； 一个返回二维存放路径（全局变量）2. 把根的值放入tempArray，判断是否与输入整数相等，是否为叶节点3. 若果不满足，递归判断左子树，直到叶节点 if(root ==NULL){ return Path; }4. 删除最后一个叶节点（即回到上一个节点）继续递归右子树 if(tempArray.size()!= 0){ tempArray.pop_back(); }5. 重复3——4步骤，直到所有路劲遍历完6. 返回满足条件的path第一次遍历 22,10,4 &emsp;&emsp;&emsp;&emsp;36！=40，因此回退到父节点10上，开始寻找右孩子。第二次遍历 22,10,8 &emsp;&emsp;&emsp;&emsp;40=40，此时正好输出这条路径（将路径添加到Path中），回退到父节点10上，此时10的左右孩子都已遍历完成，因此回退到父节点22第三次遍历 22,13,5 &emsp;&emsp;&emsp;&emsp;40=40，此时正好输出这条路径（将路径添加到Path中）. code#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; class Solution { private: vector&lt;int&gt; tempArray; vector&lt;vector&lt;int&gt;&gt; Path; public: vector&lt;vector&lt;int&gt;&gt; FindPath(TreeNode* root,int expectNumber) { if(root ==NULL){ return Path; } tempArray.push_back(root-&gt;val); if(root-&gt;val == expectNumber&amp;&amp; root-&gt;left ==NULL &amp;&amp; root-&gt;right == NULL){ Path.push_back(tempArray); } if(root-&gt;val !=expectNumber &amp;&amp; root -&gt; left != NULL ){ FindPath(root-&gt;left,expectNumber-root-&gt;val); } if(root-&gt;val!=expectNumber &amp;&amp; root-&gt;right !=NULL){ FindPath(root-&gt;right,expectNumber-root-&gt;val); } if(tempArray.size()!= 0){ tempArray.pop_back(); } return Path; } }; int main() { //构建二叉树 Solution tree; vector&lt;vector&lt;int&gt; &gt; result; TreeNode* root = new TreeNode(22); root-&gt;left = new TreeNode(10); root-&gt;right = new TreeNode(13); root-&gt;right-&gt;right = new TreeNode(5); root-&gt;left-&gt;left = new TreeNode(4); root-&gt;left-&gt;right = new TreeNode(8); result = tree.FindPath(root, 40); for (int i = 0; i &lt; result.size(); i++) { for (int j = 0; j &lt; result[i].size(); j++) { cout &lt;&lt; result[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } return 0; }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十九）","slug":"C-剑指offer刷题（十九）","date":"2020-05-01T13:28:12.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/05/01/C-剑指offer刷题（十九）/","link":"","permalink":"/2020/05/01/C-剑指offer刷题（十九）/","excerpt":"","text":"题目描述输入一个非空整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 二叉搜索树二叉搜索树左子树值都比根小，右子树值都比根大。 思路：后序遍历二叉搜索树1. 后序遍历的最后一个元素为根2. 定义两个vector存放前部分左子树，后半部分右子树3. 找出分界线 i4. 前部分放入leftArray；后半部分放入rightArray5. 递归继续1——4步骤，判断左右子树6. 左右子树都是如此划分的就放回true codeclass Solution { public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) { //存放数组前半部分左子树， 后半部分右子树 vector&lt;int&gt; leftArray,rightArray; int TreeRoot = sequence.back(); if(sequence.empty()){ return false; } //找出分解线 int i = 0;//把i写成去全局 for(;i &lt; sequence.size()-1;++i){ if(sequence[i]&gt;TreeRoot) break; } //判断右边 for(int j = i;j&lt;sequence.size()-1;++j){ if(sequence[j]&lt;TreeRoot) return false; } //前半部分放入左子树 for(int m = 0;m &lt; i;++m){ leftArray.push_back(sequence[m]); } //后半部分放入右子树 for(int n = i;n &lt; sequence.size()-1;++n){ rightArray.push_back(sequence[n]); } //判断左右子树是否为二叉搜索树 bool leftTree = true; bool rightTree = true; if(leftArray.size()&gt;0){ leftTree = VerifySquenceOfBST(leftArray); } if(rightArray.size()&gt;0){ rightTree = VerifySquenceOfBST(rightArray); } return (leftTree &amp;&amp; leftTree); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十八）","slug":"C-剑指offer刷题（十八）","date":"2020-04-30T05:45:17.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/30/C-剑指offer刷题（十八）/","link":"","permalink":"/2020/04/30/C-剑指offer刷题（十八）/","excerpt":"","text":"题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路：借助一个辅助队列1. 把二叉树存放在队列里面2. 队列的front的值放入vector中3. 如果左子树为真，左子树放入vector中4. 如果右子树为真，右子树放入vector中5. 出队列6. 返回PrintTreeNode打印出节点 code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) { vector&lt;int&gt; PrintTreeNode; //辅助队列 queue&lt;TreeNode*&gt; TempQueue; if(root == NULL){ return PrintTreeNode; } TempQueue.push(root); while(!TempQueue.empty()){ PrintTreeNode.push_back(TempQueue.front()-&gt;val); if(TempQueue.front()-&gt;left){ TempQueue.push(TempQueue.front()-&gt;left); } if(TempQueue.front()-&gt;right){ TempQueue.push(TempQueue.front()-&gt;right); } TempQueue.pop(); } return PrintTreeNode; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十七）","slug":"C-剑指offer刷题（十七）","date":"2020-04-29T04:32:33.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/29/C-剑指offer刷题（十七）/","link":"","permalink":"/2020/04/29/C-剑指offer刷题（十七）/","excerpt":"","text":"题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 由于栈的压入过程中可以向外弹元素，不一定是全部元素进栈才开始向外弹栈，所以会产生不同的弹栈顺序。压入 1、2、3、4时 &emsp;&emsp;&emsp;&emsp;弹出4压入5 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;弹出5&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 弹出3、2、1所以弹出4,5,3,2,1 思路：借助一个辅助vector1. 遍历序列1，依次存入辅助vector TempArray中2. 遍历的同时比较依次插入TempArray中的最后一个元素是否和序列2 中的第一个元素相等3. 如果不相等继续往下遍历序列14. 如果相等，就把TempArray的最后一个元素删除，再比较序列2中的下一个元素5. 最后返回TempArray是否为空，为空则是弹出序列 codeclass Solution { public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) { if(pushV.empty()){ return false; } vector&lt;int&gt; TempArray; for(int i=0,j =0;i&lt;=pushV.size()-1;i++){ TempArray.push_back(pushV[i]); while(j&lt;=pushV.size()-1 &amp;&amp; TempArray.back() == popV[j]){ TempArray.pop_back(); j++; } } return TempArray.empty(); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十六）","slug":"C-剑指offer刷题（十六）","date":"2020-04-28T03:23:33.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/28/C-剑指offer刷题（十六）/","link":"","permalink":"/2020/04/28/C-剑指offer刷题（十六）/","excerpt":"","text":"题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。 思路：借助一个辅助栈找min1. 对操作栈压栈，辅助栈压入一个值2. 比较压入栈的值与栈顶元素的大小；如果小就压栈，否则不压栈3. 如果辅助栈的值与操作栈的值相等辅助栈出栈4. 操作栈出栈5. 返回操作栈栈顶元素6. 返回辅助栈栈顶元素就是最小值 codeclass Solution { public: stack&lt;int&gt; StackStructure,AssistStack; void push(int value) { StackStructure.push(value); if(AssistStack.empty()){ AssistStack.push(value); }else if(value &lt;= AssistStack.top()){ AssistStack.push(value); } } void pop() { if(StackStructure.top() == AssistStack.top()){ AssistStack.pop(); } StackStructure.pop(); } int top() { return StackStructure.top(); } int min() { return AssistStack.top(); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十五）","slug":"C-剑指offer刷题（十五）","date":"2020-04-27T03:20:20.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/27/C-剑指offer刷题（十五）/","link":"","permalink":"/2020/04/27/C-剑指offer刷题（十五）/","excerpt":"","text":"题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 思路：遍历1. 从左向右遍历2. 从上向下遍历3. 从右向左遍历4. 从下向上遍历5. 缩小一圈 codeclass Solution { public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { //矩阵的行列 int rows = matrix.size(); int cols = matrix[0].size(); vector&lt;int&gt; PrintArray; if(rows == 0||cols == 0){ return PrintArray; } int top = 0; int right = cols-1; int bottom =rows-1; int left = 0; while (left &lt;= right &amp;&amp; top &lt;= bottom){ //从左到右 for(int i= top;i&lt;=right;++i){ PrintArray.push_back(matrix[top][i]); } //从上到下 for(int j =top+1;j&lt;=bottom;++j){ PrintArray.push_back(matrix[j][right]); } //从右到左 if (top != bottom) for(int m =right-1;m &gt;=left; --m){ PrintArray.push_back(matrix[bottom][m]); } //从下到上 if (left != right) for(int n = bottom-1;n&gt;top;--n){ PrintArray.push_back(matrix[n][left]); } ++top; --right; --bottom; ++left; } return PrintArray; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十四）","slug":"C-剑指offer刷题（十四）","date":"2020-04-26T03:09:35.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/26/C-剑指offer刷题（十四）/","link":"","permalink":"/2020/04/26/C-剑指offer刷题（十四）/","excerpt":"","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 思路：递归1. 交换根的左右子树2. 递归交换子树的左右子树 code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: void Mirror(TreeNode *pRoot) { if(!pRoot){ return; } TreeNode* tempTree = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tempTree; //递归左子树 Mirror(pRoot-&gt;left); //递归右子树 Mirror(pRoot-&gt;right); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十三）","slug":"C-剑指offer刷题（十三）","date":"2020-04-25T03:15:50.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/25/C-剑指offer刷题（十三）/","link":"","permalink":"/2020/04/25/C-剑指offer刷题（十三）/","excerpt":"","text":"题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路：二叉树递归1. 判断根节点是否相同2. 若果不同，A的左子树与B的根比较；A的右子树与B的根比较3. 判断是否是子结构4. 检查A和B是否已经遍历完了5. 不相等就返回false6. 相等A和B的左子树是否相等，A和B的右子树是否相等，都相等B是A的子结构，否则不是 code/* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) { //B为空不是子结构 if(pRoot2 == NULL){ return false; } //A为空肯定没有子结构 if(pRoot1 == NULL){ return false; } //判断第一个根节点是否相同 bool flag = IsSubTree(pRoot1,pRoot2); //判断A的左子树有没有B子结构 if(!flag){ flag = HasSubtree(pRoot1-&gt;left,pRoot2); } //判断A的右子树有没有B子结构 if(!flag){ flag = HasSubtree(pRoot1-&gt;right,pRoot2); } return flag; } bool IsSubTree(TreeNode* pSub1,TreeNode* pSub2){ //判断B中还是否有子树 if(pSub2 == NULL){ //B已经没有子树了，但是和A是相同的 return true; } //A已经没有子树了，B还有，则B肯定不是A的子结构 if(pSub1 == NULL){ return false; } if(pSub1-&gt;val != pSub2-&gt;val){ return false; } //继续遍历左右子树 return IsSubTree(pSub1-&gt;left,pSub2-&gt;left) &amp;&amp; IsSubTree(pSub1-&gt;right,pSub2-&gt;right); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十二）","slug":"C-剑指offer刷题（十二）","date":"2020-04-24T04:51:50.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/24/C-剑指offer刷题（十二）/","link":"","permalink":"/2020/04/24/C-剑指offer刷题（十二）/","excerpt":"","text":"题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路1：链表指针1. 定义一个新的链表，确定头结点2. 比较大小，穿线3. 链表指针向后移动，合并链表指针也向后移动4. 如果输入链表长度不一致5. 一个为空之后直接返回另一个 code1/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(!pHead1){ return pHead2; } if(!pHead2){ return pHead1; } ListNode* newList = NULL; //拿出一个小的值作为头结点 if(pHead1-&gt;val&lt;=pHead2-&gt;val){ newList = pHead1; pHead1 = pHead1-&gt;next; }else{ newList = pHead2; pHead2 = pHead2-&gt;next; } ListNode* newListP = newList; while(pHead1 &amp;&amp; pHead2){ if(pHead1-&gt;val&lt;=pHead2-&gt;val){ newListP-&gt;next = pHead1;//穿线 pHead1 = pHead1-&gt;next;//第一个指针向后移 newListP = newListP-&gt;next;//合并后的指针也向后移动 }else{ newListP-&gt;next = pHead2;//穿线 pHead2 = pHead2-&gt;next;//第二个指针向后移 newListP = newListP-&gt;next; } } //如果两个链表长度不一样 if(pHead1 == NULL){ newListP-&gt;next = pHead2; } if(pHead2==NULL){ newListP-&gt;next = pHead1; } return newList; } }; 思路2：递归法1. 定义一个新的链表2. 比较大小,较小的依次放入newList3. newList下一个用未比较的继续比较，较小的依次放入newList code/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { if(!pHead1){ return pHead2; } if(!pHead2){ return pHead1; } ListNode* newList = NULL; if(pHead1-&gt;val&lt;=pHead2-&gt;val){ newList = pHead1; newList-&gt;next = Merge(pHead1-&gt;next,pHead2); }else{ newList = pHead2; newList-&gt;next = Merge(pHead1,pHead2-&gt;next); } return newList; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十一）","slug":"C-剑指offer刷题（十一）","date":"2020-04-23T02:55:50.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/23/C-剑指offer刷题（十一）/","link":"","permalink":"/2020/04/23/C-剑指offer刷题（十一）/","excerpt":"","text":"题目描述链表查找输入一个链表，输出该链表中倒数第k个结点。 思路：快慢指针1. 定义两个指针指向链表2. front先向前移动k个单位3. front 和 after同时向前移动4. 直到front指向NULL5. 返回after 实现code/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(pListHead == NULL || k&lt;1){ return NULL; } ListNode* front = pListHead; ListNode* after = pListHead; while(k&gt;0){ if(front == NULL){ //当移动k时，链表不够长，返回NULL return NULL; } front = front-&gt;next; k--; } while(front!= NULL){ front = front-&gt;next; after = after-&gt;next; } return after; } }; 链表反转输入一个链表，反转链表后，输出新链表的表头。（反转链表也要输出） 思路：头插法1. 从原链表的头部一个一个取节点并插入到新链表的头部 code/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public: ListNode* ReverseList(ListNode* pHead) { ListNode* reversal = NULL; ListNode* initial = pHead; if(pHead == NULL || pHead-&gt;next == NULL){ return pHead; } while(initial != NULL){ ListNode* next = initial-&gt;next; initial-&gt;next = reversal; //反转 reversal = initial; initial = next; } return reversal; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（十）","slug":"C-剑指offer刷题（十）","date":"2020-04-22T08:20:38.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/22/C-剑指offer刷题（十）/","link":"","permalink":"/2020/04/22/C-剑指offer刷题（十）/","excerpt":"","text":"题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 173245238927173539724282 思路1：找偶数存新数组1. 定义一个迭代器，2. 遍历找出偶数3. 删除偶数4. 把偶数放回array中173539724282173539724282 实现code1class Solution { public: void reOrderArray(vector&lt;int&gt; &amp;array) { vector&lt;int&gt; tempArray; vector&lt;int&gt;::iterator iter = array.begin(); for(;iter!=array.end();){ if(((*iter)&amp;1) == 0){ tempArray.push_back(*iter); //偶数放在临时数组中 iter = array.erase(iter); //删除偶数的位置 }else{ iter++; //奇数迭代器加1 } } //把新得的偶数放回array 中 vector&lt;int&gt;::iterator iterNew = tempArray.begin(); for(;iterNew != tempArray.end();iterNew++){ array.push_back(*iterNew); } } }; 思路2：前后同时遍历1. 定义一个新数组2. 遍历array3. 奇数从前往后遍历 ————&gt; 从前往后放4. 偶数从后往前遍历 ————&gt; 从后往前放5. 叠加到arrayfirst&darr;&emsp;&emsp;&rArr;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lArr;&emsp;&emsp;end&darr;1732452389271735282 实现code2class Solution { public: void reOrderArray(vector&lt;int&gt; &amp;array) { int PreToEnd = 0; int EndToPre = array.size()-1; int *temp = new int[array.size()](); for (int i = 0; i &lt; array.size(); i++) { if ((array[i]&amp;1)==1) { temp[PreToEnd++] = array[i]; } if ((array[array.size() - i - 1]&amp;1) == 0) { temp[EndToPre--] = array[array.size() - i - 1]; } } for(int i= 0;i&lt;array.size();i++){ array[i]=temp[i]; } } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（九）","slug":"C-剑指offer刷题（九）","date":"2020-04-21T08:12:03.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/21/C-剑指offer刷题（九）/","link":"","permalink":"/2020/04/21/C-剑指offer刷题（九）/","excerpt":"","text":"题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0。 n为奇数时, n&amp;1为1n为偶数时, n&amp;1为0n&amp;1等效于 n%2==1 “n&gt;&gt; 1”与操作与”n/2” . &gt;&gt;是右移符号，它在操作时只允copy许整数. /是除法，它可以操作不同类型的数据(int float) 右移操作通常情况下，会比整数除法速度快 右移运算的优先级比除法低，先计算乘除，后计算左移或右移 思路:指数计算1. 先判断base==0 exponent &gt; 0 结果为0 否则错误2. 判断base！=0 exponent &gt; 0 计算公式计算 exponent = 0 计算结果为1 exponent &lt; 0 去倒数3. 计算公式 实现codeclass Solution { public: double Power(double base, int exponent) { if(base == 0){ if(exponent &gt;0){return 0;} else { throw std::invalid_argument(&quot;input error（divisor！=0）||0 at the same time）&quot;); } }else{ if(exponent &gt; 0){ return PerformOperation(base,exponent);} else if(exponent == 0){return 1;} else{return 1/PerformOperation(base,-exponent);} } } double PerformOperation(double base,int exponent){ if(exponent == 1){return base;} if((exponent &amp; 1) ==0){ double Temp_Even = PerformOperation(base,exponent &gt;&gt; 1); return Temp_Even*Temp_Even; }else{ double Temp_Odd = PerformOperation(base,(exponent - 1) &gt;&gt; 1); return Temp_Odd*Temp_Odd*base; } } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（八）","slug":"C-剑指offer刷题（八）","date":"2020-04-20T02:44:20.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/20/C-剑指offer刷题（八）/","link":"","permalink":"/2020/04/20/C-剑指offer刷题（八）/","excerpt":"","text":"题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 补码补码是计算机中用来表示负数，使得负数能够使用加法器参与加法运算的一种码。（将减法变为加法） 一个数的数值是11，他的模是16，那么他的补码是多少16-11 = 5，即补码就是5。 模为32，使用补码运算该算式16-13，13 - 16。 16-13 = (16 + （32-13）)% 32 = 35 % 32 = 313-16 = (13 + （32-16）)% 32 = 29 % 32 = 29 正数的补码即为自己负数的补码为符号位不变，其余逐位求反再加1。 正数，符号位为0，负数，符号位为1 思路:位操作现象：我们把这个整数减1，那么原来处在整数最右边的1就会变为0在1后面的所有的0都会变成1其余所有位将不会受到影响。1.把一个整数减去12.再和原整数做与运算（整数的二进制有多少个1，就可以进行多少次这样的操作）3.直到变为0结束 实现codeclass Solution { public: int NumberOf1(int n) { int count = 0; while(n!= 0){ ++count; n = n &amp; (n - 1); } return count; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（七）","slug":"C-剑指offer刷题（七）","date":"2020-04-19T03:51:20.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/19/C-剑指offer刷题（七）/","link":"","permalink":"/2020/04/19/C-剑指offer刷题（七）/","excerpt":"","text":"题目描述要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n:0123456789斐波那契数列:0112358132134 思路1：动态数组记录前两项的值，当前项只需要进行一次加法运算1.申请一个动态数组存放前两项的值，要输出某一项只需要将前两项相加2.输出数组中的某项3.释放空间这样时间复杂度O(n)，空间复杂度O(n) 实现code1class Solution { public: int Fibonacci(int n) { int temp; if(n&lt;=0) return 0; int *Arraylist=new int[n+1]; Arraylist[1]=Arraylist[2]=1; for(int i=3;i&lt;=n;i++) { Arraylist[i]=Arraylist[i-1]+Arraylist[i-2]; } temp=Arraylist[n]; return temp; delete []Arraylist; } }; 思路2：迭代法中间的结果不需要记录1.每次记录前一项2.迭代辗转相加这样时间复杂度O(n)，空间复杂度O(1) 实现code2class Solution { public: int Fibonacci(int n) { int i; int PreItem =0; int CurrentItem =1; if(n&lt;=0) return 0; if(n==1) return 1; for(i=2;i&lt;=n;i++){ CurrentItem = PreItem+CurrentItem; PreItem = CurrentItem-PreItem; } return CurrentItem; } }; 斐波那契数列的应用跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路1：数组保存记录前面的值对于第n个台阶来说，只能从n-1或者n-2的台阶跳上来，所以F(n) = F(n-1) + F(n-2)斐波拉契数序列，初始条件n=1:只能一种方法n=2:两种刚好满足斐波拉契数列 实现code1class Solution { public: int jumpFloor(int number) { int temp; int *Arraylist=new int[number+1]; Arraylist[0]=1; Arraylist[1]=1; for(int i=2;i&lt;=number;i++) { Arraylist[i]=Arraylist[i-1]+Arraylist[i-2]; } temp=Arraylist[number]; return temp; delete []Arraylist; } }; 思路2：迭代法中间的结果不需要记录1.每次记录前一项2.迭代辗转相加 实现code2class Solution { public: int jumpFloor(int number) { int i; int PreItem =1; int CurrentItem =1; if(number&lt;=0) return 0; if(number==1) return 1; for(i=2;i&lt;=number;i++){ CurrentItem = PreItem+CurrentItem; PreItem = CurrentItem-PreItem; } return CurrentItem; } }; 变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路:位操作n = 1 1中跳法n = 2 2中跳法n = 3 4中跳法n = 4 8中跳法…n = number 2 ^(number - 1) 中跳法直接按位操作m*2^n 相当于将m左移n次m/2^n 相当于将m右移n次 实现codeclass Solution { public: int jumpFloorII(int number) { int shift = 1; //将要移位的数 1* 2^(n-1) return 1&lt;&lt;(number - 1); } }; 矩形覆盖我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路:迭代法 其实也是斐波拉契数列 实现codeclass Solution { public: int rectCover(int number) { int i; int PreItem =1; int CurrentItem =1; if(number&lt;=0) return 0; if(number==1) return 1; for(i=2;i&lt;=number;i++){ CurrentItem = PreItem+CurrentItem; PreItem = CurrentItem-PreItem; } return CurrentItem; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（六）","slug":"C-剑指offer刷题（六）","date":"2020-04-18T06:53:57.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/18/C-剑指offer刷题（六）/","link":"","permalink":"/2020/04/18/C-剑指offer刷题（六）/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 01234567891011&emsp;first&darr;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;middle&darr;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; end&darr;123456789101112&emsp;first&darr;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;middle&darr;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; end&darr;789101112123456&emsp;first&darr;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;middle&darr;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; end&darr;334552222222 思路：二分法查找由于数组是递增的，旋转之后实际上前一部分是递增的，后一部分也是递增的。利用二分查找：如果中间元素值大于最后一个元素值，说明最小值在右半区间，如果中间元素值小于最后一个元素值，说明最小值在左半区间，或者min就是这个中间值如果相等说明有相同元素，需要将判断区间往前缩一下，继续判断。不断循环，当二分查找的的左右区间相等了，就说明找到最小值了。 实现codeclass Solution { public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) { if(rotateArray.size()==0){ return 0; } //定义组数开始、中间、结尾的下标 int first = 0; int end = rotateArray.size()-1; int middle = 0; while(first&lt;end){ middle = (first+end)/2; //当中间元素 大于 最后一个元素，说明最小值在右半区间 //此时缩小区间first 到 end if(rotateArray[middle]&gt;rotateArray[end]){ first +=1; }else if(rotateArray[middle]&lt;rotateArray[end]){ //当中间元素 小于 最后一个元素 ，说明最小值在右半区间，并且这个中间值也可能是最小值 end = middle; }else{ //中间元素 等于 最后一个元素，存在重复的元素，只能缩小一个范围 end -=1; } } return rotateArray[first]; } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（五）","slug":"C-剑指offer刷题（五）","date":"2020-04-18T05:21:06.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/18/C-剑指offer刷题（五）/","link":"","permalink":"/2020/04/18/C-剑指offer刷题（五）/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 思路：一个栈存放入队列，另一个栈用来出队列1.对列入队：借助stack1的压栈push2.对列出对：&emsp;&emsp;&emsp; ●借助stack2，把stack1出栈的值放入stack2中&emsp;&emsp;&emsp; ●stack2出栈也就是队列的出对 实现codeclass Solution { public: void push(int node) { stack1.push(node); } int pop() { if(stack2.empty()){ while(!stack1.empty()){ stack2.push(stack1.top()); stack1.pop(); } } int QueenTemp = stack2.top(); stack2.pop(); return QueenTemp; } private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2; };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（四）","slug":"C-剑指offer刷题（四）","date":"2020-04-17T05:29:38.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/17/C-剑指offer刷题（四）/","link":"","permalink":"/2020/04/17/C-剑指offer刷题（四）/","excerpt":"","text":"题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 先序遍历先访问根，先序遍历左子树，左子树为空或者已遍历访问右子树 中序遍历先访问左子树，左子树为空或者已遍历访问根，中序遍历右子树 后序遍历后序遍历左子树，后序遍历右子树，左右子树为空或者已遍历才访问根 层次遍历从根开始从左到右依次遍历 还原二叉树中序分左右 前序后序确定根 思路：还原二叉树实际上是递归的思想1.通过前序或者后序确定根2.new一个还原后二叉树&emsp;&emsp;&emsp; TreeNode* PTree = new TreeNode(Root);3.将前序和中序除了根以外的划分成左右子树分别存储在PreL、PreR、MidL、MidR中4.递归构建二叉树的左右子树 实现code/** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) { if(pre.empty()||vin.empty()||pre.size()!=vin.size()){ return NULL; } return Pre_Mid_ConstructBinaryTree(pre,vin); } TreeNode* Pre_Mid_ConstructBinaryTree(vector&lt;int&gt; &amp;pre,vector&lt;int&gt; &amp;mid){ //确定根（前序遍历的第一个数就是根） int Root = pre[0]; //New一个重建二叉树 TreeNode* PTree = new TreeNode(Root); //将中序遍历的结果分为左右两个部分放入vector中 vector&lt;int&gt; MidL; vector&lt;int&gt; MidR; //前序遍历的结果从根之后开始依次是左子树和右子树，同样也单独存放在vector中 vector&lt;int&gt; PreL; vector&lt;int&gt; PreR; int i = 0;int j =1; //分别找出前序和中序的左子树 while(mid[i]!=Root){ MidL.push_back(mid[i++]); PreL.push_back(pre[j++]); } //跳过中序遍历中的根 ++i; //分别找出前序和中序的右子树 while(i&lt;mid.size()){ MidR.push_back(mid[i++]); PreR.push_back(pre[j++]); } //构建左右子树 if(!MidL.empty()&amp;&amp; !PreL.empty()){ PTree-&gt;left = Pre_Mid_ConstructBinaryTree(PreL,MidL); } if(!MidR.empty()&amp;&amp; !PreR.empty()){ PTree-&gt;right = Pre_Mid_ConstructBinaryTree(PreR,MidR); } return PTree; } }; ● 使用指针还原前中序还原、后中序还原 //前序中序还原建立二叉树 TreeNode* pre_mid_createBiTree(char *pre,char *mid,int len) { if(len==0) return NULL; char ch=pre[0]; //找到先序中的第一个结点 int index=0; while(mid[index]!=ch)//在中序中找到的根结点的左边为该结点的左子树，右边为右子树 { index++; } TreeNode* T=new TreeNode(ch);//创建根结点 T-&gt;data=ch; T-&gt;lchild=pre_mid_createBiTree(pre+1,mid,index);//建立左子树 T-&gt;rchild=pre_mid_createBiTree(pre+index+1,mid+index+1,len-index-1);//建立右子树 return T; } //后序中序还原建立二叉树 TreeNode* pro_mid_createBiTree(char *last,char *mid,int len) { if(len==0) return NULL; char ch=last[len-1]; //取得后序遍历顺序中最后一个结点 int index=0;//在中序序列中找根结点，并用index记录长度 while(mid[index]!=ch)//在中序中找到根结点，左边为该结点的左子树，右边为右子树 index++; TreeNode* T=new TreeNode(ch);;//创建根结点 T-&gt;data=ch; T-&gt;lchild=pro_mid_createBiTree(last,mid,index);//建立左子树 T-&gt;rchild=pro_mid_createBiTree(last+index,mid+index+1,len-index-1);//建立右子树 return T; }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（三）","slug":"C-剑指offer刷题（三）","date":"2020-04-16T02:20:57.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/16/C-剑指offer刷题（三）/","link":"","permalink":"/2020/04/16/C-剑指offer刷题（三）/","excerpt":"","text":"题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 思路1：借助栈stack先进后出反弹至vector中1.定义一个链表指针指向输入的链表 保存链表类型的地址。2.遍历输入的链表，依次压栈。3.每次取出栈顶元素放入vector容器中。4.出栈 实现code1/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) { //借助栈 //创建一个链表指针指向输入的链表 ListNode *p =NULL; p = head; stack&lt;int&gt; TempStack; //定义一个栈 vector&lt;int&gt; ArrayList; //定义一个vector容器 while(p!=NULL){ //压栈 TempStack.push(p-&gt;val); p=p-&gt;next; } while(!TempStack.empty()){ //把出栈的值放到vector容器中也就是返回的ArrayList ArrayList.push_back(TempStack.top());//栈顶的元素放到ArrayList中 //出栈 TempStack.pop(); } return ArrayList; } }; 思路2：使用反向迭代器所有容器都定义了 begin 和 end 成员，分别返回指向容器首元素和尾元素下一位置的迭代器。容器还定义了 rbegin 和 rend 成员，分别返回指向容器尾元素和首元素前一位置的反向迭代器，如下图所示：1.遍历链表内容存放到vector容器中。2.使用反向迭代器直接返回。 实现code2/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) { vector&lt;int&gt; ArrayList; //定义一个vector容器 //创建一个链表指针指向输入的链表 ListNode *p =NULL; p = head; while(p!=NULL){ ArrayList.push_back(p-&gt;val); p = p-&gt;next; } //返回一个反向迭代器 return vector&lt;int&gt;(ArrayList.rbegin(),ArrayList.rend()); } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（二）","slug":"C-剑指offer刷题（二）","date":"2020-04-15T00:44:11.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/15/C-剑指offer刷题（二）/","link":"","permalink":"/2020/04/15/C-剑指offer刷题（二）/","excerpt":"","text":"题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为I am raylee.则经过替换之后的字符串为I%20am%20raylee。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;*originpStr &darr; Iamraylee\\0 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;*newpStr &darr; Iamraylee\\0 思路：搜索从前往后搜索，插入的时候从后往前插入1.求出原始字符串大小。2.求出空格数。3.计算新字符串大小 blankSpaceCount*2 + originStrLen 。4.定义两个指针指向原始和新字符串的末尾。5.往前一次遍历：&emsp;&emsp;当originStrLen指向空的时候，就开始替换，newpStr减一插入一个，减一插入一个，知道满足要求。&emsp;&emsp;当originStrLen不指向空时，把原始字符串的复制给新字符串。6.每操作完一次原始指针减一，往前遍历。 实现codeclass Solution { public: void replaceSpace(char *str,int length) { //验空 if(str ==nullptr || length&lt;=0 ){ return; } //求出原始字符串长度 int blankSpaceCount = 0; int originStrLen = 0; //求出空格数 for(int i = 0;str[i]!=&#39;\\0&#39;;i++){ originStrLen++; if(str[i]==&#39; &#39;){ blankSpaceCount++; } } int newStrLen = blankSpaceCount*2 + originStrLen; char *originpStr = str + originStrLen; char *newpStr = str + newStrLen; while(originpStr &lt; newpStr){ if(*originpStr== &#39; &#39;){ *newpStr-- = &#39;0&#39;; *newpStr-- = &#39;2&#39;; *newpStr-- = &#39;%&#39;; }else{ *newpStr--= *originpStr; } originpStr--; } } };","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"C++剑指offer刷题（一）","slug":"C-剑指offer刷题（一）","date":"2020-04-13T11:45:49.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/13/C-剑指offer刷题（一）/","link":"","permalink":"/2020/04/13/C-剑指offer刷题（一）/","excerpt":"","text":"题目描述&emsp;&emsp;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819202122232425&emsp;&emsp;例如以上一个5X5的二维数组从左到右递增，从上到下递增，假如target这个数是12，判断12 是否在这个二维数组中 思路：确定右上角数的X、Y坐标。&emsp;&emsp;如果target比右上角值大，肯定在下一行，行往下找。&emsp;&emsp;如果target比右上角值小，肯定在最后一列的左边，列往左找。 实现Code：class Solution{ public: bool Find (int target, vector&lt;vector&lt;int&gt; &gt; array){ //找到数组的行 int rows = array.size(); //找到数组的列 int cols = array[0].size(); //找到右上角的数的X Y坐标 int rowX = 0; int rowY = cols-1; //数组范围内查找 while(rowX &lt; rows &amp;&amp; 0 &lt;= rowY){ if(target &gt; array[rowX][rowY]){ rowX++; }else if(target &lt; array[rowX][rowY]){ rowY--; }else return true; } return false; } }; vecter 定义一个二维数组： vector&lt;vector&lt;int&gt; &gt; array 二维数组确定行列 //行 把每一行看成一个整体 int rows = array.size(); //列 第一行的个数 int cols = array[0].size();","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"S32V234","slug":"S32V234","date":"2020-04-08T09:14:47.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/08/S32V234/","link":"","permalink":"/2020/04/08/S32V234/","excerpt":"","text":"S32V234StudyS32VS32V234 相关硬件架构&amp;相关术语 S32V234 S32V 基础概念及名词解释 S32V environmentS32V234 Soc linux环境搭建&amp;BSP制作 S32V234 用 Visual Studio Code 搭建 S32V234 编译环境 SensorS32V234 摄像头与光学 | Camera 信号波形状态总结及同步方式 S32V234 摄像头与光学 | 摄像头基本知识 S32V234 摄像头与光学 | SENSOR &amp; ISP 简介及 Tuning Guide S32V234 SerDes + OV Sensor 驱动调试 S32V234 摄像头驱动调试 APEXS32V234 APEX 架构介绍 S32V234 APEX 数据组织和具体的处理流程 S32V234 Linux环境的 APEX 范例编译 S32V234 如何运用 ApexCV Library 建立第一支程式 (Linux 编程) S32V234 S32DS 中新建 Kernel 算子并编译（上） S32V234 S32DS 中新建 Kernel 算子并编译（下） ISPS32V234 ISP Graph 创建实例 S32V234 S32DS 构建graph S32V234 ISP中Debayer是什么 S32V234 ISP Demo 程序创建及运行 S32V234 ISP Graph 的动态调度和静态调度 on S32DS S32V234 如何抓取图像的 Buffer 进而分析 S32V234 ISP kernel 设计指南 S32V234 ISP kernel 设计指南 2 S32V234 如何从无到有完成 ISP kernel 算子的参数调整（上） S32V234 如何从无到有完成 ISP kernel 算子的参数调整（下） CANCAN协议 S32V234 CAN总线通信测试 进程通信 ARMS32V234 ARM 中 NEON 使用 Hands on (上) S32V234 ARM 中 NEON 使用 Hands on (下) ADASS32V234 构建ISP_APEX ADAS GPU driverS21V234 GPU驱动编译 BSPS32V234 Yocto 搭建系统平台 S32V234 ARM 中 NEON 使用 Hands on (上) S32V234 ARM 中 NEON 使用 Hands on (下) S32V234 优化 S32V Yocto BSP &amp; VSDK 环境搭建流程 S32V234 手动制作NFS方式启动 initramfs 调试 S32V234 CSE 模块相关介绍 S32V234 U-boot 环境变量初始化 DCUS32V234 DCU &amp; FrameBuffer Hands On Memory Stress TestS32V234 S32V234 Memory Stress Test（上） S32V234 S32V234 Memory Stress Test（下） S32V FAQS32V234 移植 S32DS_Vision_v2.0 Sample Code 至 Linux 上开发 S32V234 Ubuntu16.04 中 S32DS 的 APEX 工程无法仿真","categories":[{"name":"link","slug":"link","permalink":"/categories/link/"}],"tags":[],"keywords":[{"name":"link","slug":"link","permalink":"/categories/link/"}]},{"title":"ComputerNet","slug":"ComputerNet","date":"2020-04-03T08:50:18.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/03/ComputerNet/","link":"","permalink":"/2020/04/03/ComputerNet/","excerpt":"","text":"计算机网路概述局域网(LAN)● 同一网络下，不同计算机使用的是局域网，覆盖范围小，自己花钱买设备，贷款固定，自己维护 广域网（WAN）● 链接不同地区的局域网，形成一个大范围的网络 数据通讯过程客户端到服务器端发生了什么？ 图片1 每个计算机有自己的IP和mac地址（计算机的物理地址），子网掩码255代表网络部分，0代表主机部分当我们在浏览器输入URL时，DNS把我们的域名解析成相应URL 网页存放的IP地址，此时访问计算机就知道被访问的IP地址。 数据包：包括数据和本机ip 和目标ip data 本机IP 目标IP 数据 12.0.0.1 17.0.0.2 数据帧：数据包加上本机和目标服务器的mac地址 data 本机IP 目标IP 本机mac 目标mac 数据 12.0.0.1 17.0.0.2 mac本机 mac目标 往下传播时，更新数据帧mac 地址，去找到最终存放网页数据IP计算机，A—F—D—H。服务器收到客户端的请求之后，会反馈给客户端，首先，服务器把网页切割成小的数据包，一个一个放入缓存区里面，传一个给客户端之后，客户端收到数据，再反馈服务器端传下一个数据包（若果客户端不给反馈，服务器端会重新再发一个数据包 ），更新缓存区，知道数据接收完为止。 数据通讯的OSI模型●应用层：所有能产生网络流量的应用程序●表示层：在传输之前是否进行加密或者压缩 （二进制、ASCLL）●会话层：查看传输过程中的木马 netstat -n, 是否存在其他病毒干扰传输●传输层：可靠传输，流量控制，不可靠传输（直接传输，客户端直接到达DNS传输）●网络层：负责选择最佳路径，规划IP地址●数据链路层：帧的开始和结束，透明传输，差错校验●物理层：接口标准，电器压标准，如何在物理链路上传输更快","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"OS_MemoryManagement","slug":"OS-MemoryManagement","date":"2020-04-02T12:21:30.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/02/OS-MemoryManagement/","link":"","permalink":"/2020/04/02/OS-MemoryManagement/","excerpt":"","text":"存储管理存储器功能容量大、速度快、信息永久保存、多道程序并行（共享，保护） 内存管理功能地址映射把程序的地址（虚拟地址/逻辑地址/虚地址），变换为内存中真实的地址（实地址/物理地址） 地址映射有三种方式： 1.固定地址映射（编程时直接使用物理地址或者通过编译器映射物理地址 ）2.静态地址映射（程序装入时由操作系统完成逻辑到物理的过程，装入时是指：双击图标时/终端输入命令回车时）物理地址（MA）=逻辑地址（VA）+装入基址（BA） MA = X + BA●程序运行之前确定映射关系●程序装入后不能移动●程序占用连续空间 3.动态地址映射程序在执行过程中将逻辑转化为物理地址内存占用空间可动态变化程序不用占用连续的内存空间便于多个进程共享代码 虚拟存储内存分配分配空间 存储保护防止越界或者越权。采用界址寄存器，在CPU中设置一对上限寄存器和下限寄存器存储程序在内存中的上限和下限 物理内存管理单一区存储分区存储1.固定分区（找合适的分区运行） 2.动态分区（存在空间碎片） 空闲区放置策略 1.分区回收（释放与现有空闲区相邻，先合并再更新空闲区，不相邻直接插入空闲区）2.内存覆盖技术 用较小的空间运行较大的程序有常驻区和覆盖区编程复杂程序执行时间变长：从外存装入内存耗时 3.内存交换技术内存不够时把进程写入磁盘，运行时再换回内存要运行B 先换出A，运行B。当要运行A的时候再把A换回内存。此时A放入内存的什么位置？（1）.放到原来的位置：简单，可能会造成地址冲突（2）.放到任意位置，灵活运用内存，地址需要重定位 解决碎片问题1.规定门限值，分割空闲区域时，若剩余部分小于门限值，不分割，全部分配给用户2.内存拼接技术：将所有空闲区集中构成一个大的空闲区（消耗资源系统，离线拼接，重新定义作业）(1)在释放回收的时候：频率大，内存开销大(2)系统找不到空间的时候：空闲区管理(3)定期：空闲区管理3.解除程序占用连续内存才能运行的限制 虚拟内存●物理内存有以下几种缺点：源程序知直接使用内存的物理地址，程序访问容易引起冲突程序必须全部装入内存才能运行，内存小而不能满足程序占有连续的一片内存，产生内存碎片多程序同事运行相互干扰 虚拟内存使得较大的和多个程序在小的内存中运行多个程序并发运行地址不冲突内存利用率高，无碎片 实现思路程序运行时，只把当前必要的很小一部分代码和数据装入内存，其余的需要的时候再装入，不运行的代码和数据及时从内存中删除 典型的虚拟内存管理方式页式虚拟内存管理 只把程序部分页装入内存中便可运行页在内存中占用页框不比相邻需要页时按需从硬盘中调入内存不运行的页，及时删除 1.页式地址映射虚拟地址（VA）可以分解成页号（P）和页内偏移（W）若页的大小（2^n）P = VA / 页的大小 = VA &gt;&gt; nW= VA %页的大小 =低n位 = VA&amp;&amp;（2^n -1）由于页是直接平移到页框上，他们直接的对应关系使用页表记录 虚拟地址（页式）——&gt; 物理地址1).从VA中分离P和W2).查页表，搜索某个页号P在页框中的索引P13).某个页号物理地址MA = P1 * X页的大小 +W 2.块表机制（cache）慢表：页表放在内存中快表：页表放在cache中快表容量小，访问快，他是慢表的部分内容复制；地址映射优先访问快快表，若快表中找到所虚的数据，叫命中，若果没有命中需要访问慢表，然后在更新快表。 普通页表采用软件对比，快表采用硬件对比 3.页面的共享可以节省空间。比如Windows系统的动态链接库是程序共享的 不同的进程有相同的页框号，多个进程访问相同的内存 在页表中加入中断位，用来标识页是否在内存中，不在内存用1 ；在，用0标识。在页表中加入访问位和修改位，0未修改，未访问；1 修改过，访问过缺页中断，在地址映射过程中，所访问的目的也不在内存中，则系统产生异常中断（缺页中断）缺页中断程序，把所缺的页从辅存调入内存中的某个页框，并更某个页框号，修改中断位为0访存指令： 缺页率 = 缺页次数/访问页面总次数 4.页面淘汰算法页面在内存和辅存之间频繁交换叫做抖动1).最佳算法（OPT）淘汰以后不再需要或者最远的将来才会用到的页面理想状态，无法实现 2).先进先出淘汰算法（FIFO）淘汰在内存中停留时间最长的页面实现简单，但是进程只有按顺序访问地址空间时，页面命中率才很理想，随着页框数增加，缺页率反而增加 3).淘汰最长时间未被使用的页面（LRU）通过移位寄存器来实现，每个页面被访问则将其重置1，周期性的左移，记录值。 4).最不经常使用算法（LFU）访问次数最少的淘汰 5.缺页的因素●淘汰算法●分配的页框数（页框越少，越容易缺页）●页本身的大小（页面越小，越容易缺页）●程序的编制方法●由于局部性原理，上面的程序运行效率更好，二维数组按行存储，下面按列遍历会产生跳转，会导致更高的缺页率，局部性差 6.页式系统的不足页面划分无逻辑页的共享不灵活页内碎片 段式存储管理把进程按逻辑意义划分多个段，一段为单位，每个段连续存储，每个段间是独立的，段与段间不相邻段式虚拟地址（VA）有段号，段内偏移（W） 段表 记录段号（S），段长（L），该段的在内存的基地址即基地址（B） MA = B+W0≤W≤L 1.段氏缺点段需要连续存储段的最大尺寸收到内存大小的限制在辅存中管理可变尺寸的段比较困难 2.段与页的区别段长可变 ，页面大小固定段的划分有意义，页的划分无意义段方便共享，页面共享不方便段是程序员划分的，页面用户不可见段偏移有溢出，页面无偏移溢出 段页式存储管理段中划分页面 段页式地址映射过程 Intel CPU的物理结构实模式20 位，1M内存空间地址表示方式：段地址（16位）+偏移地址（16位）直接存储物理地址 保护模式32位，4G内存多增加新的寄存器 ●开机从实模式转到保护模式 控制寄存器CR0：PE位：0实模式；1 保护模式PG允许分页 控制器CR2：保存缺页的线性地址控制器CR3：页目录的基址 逻辑地址在实模式下是段基址+偏移值逻辑地址在保护模式下段选择子+偏移值 段与段描述符 描述符数据结构（段基址：32位 段界限： 20 位）描述符表里面放的描述符 描述符表的类型全局描述符（GDT）：包含所有进程 的段描述符局部描述符（LDT）：特定进程有关的描述符中断描述符（IDT）：包含中断服务程序段描述符 选择子 Linux三级页表结构将4M的超大页表存储到1K个页框中。页表按需调入内存 Linux段机制用户空间：3G 0—0xBFFFFFFF内核空间：1G 0xC0000000—0xFFFFFFFF进程创建时，段机制对寄存器初始化 ●内核特权级为0●用户特权级为3 作用●利用段机制隔离用户数据和系统数据●简化逻辑到线性地址的转化，可直接将虚拟地址当做线性地址 下一篇继续记录（来自华中科技大学操作系统原理学习）","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"OS_FileManagement","slug":"OS-FileManagement","date":"2020-04-02T12:20:33.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/02/OS-FileManagement/","link":"","permalink":"/2020/04/02/OS-FileManagement/","excerpt":"","text":"设备管理主要功能1.设备分配共享设备分配（包括所有的块设备，多进程交替使用同一设备。例如磁盘）独占设备分配（包括所有的字符型设备，任意时间内最多被一个进程占用，例如：键盘，打印机）使用过程：申请——》使用——》释放虚拟分配在一类物理设备上模拟另一类物理设备，虚拟光驱 借助辅存部分区域模拟独占设备，将独占设备转化为共享设备；当进程需要与独占设备交换信息时，就采用虚拟技术将与该独占设备所对应的虚拟设备分配给他例如SPOOLing系统(外部设备同时联机操作) 2.设备映射：逻辑设备映射到物理设备 3.设备驱动：对物理设备进行控制实现I/O操作；接受应用的服务请求；向用户提供统一接口 设备驱动程序的特点:●它与硬件相关●每一类的设备都有特定的驱动程序●驱动程序一般由厂商根据操作系统要求编写●操作系统仅对设备驱动的接口提出要求 Linux内核模块（解决单体内核机制的不足）未经链接的可执行代码经过装载成为内核的一部分然后动态的装载和卸载 编译模块： gcc -o xxmoudle.ko _D_KERNEL_ -MOUDLE xxx.c 安装: sudo insmod xxmoudle.ko 还可以带参数（Sudo insmod xxmoudle.ko str = “xxx” intval = 4） 删除模块： sudo rmmod moudle 查看内核信息: dmesg 查看模块： Lsmod Linux驱动程序驱动程序工作在内核态 1.驱动设备分为：字符设备(执行ls -L/dev c)块设备（b）网络设备（socket） 硬件设备都可看成设备文件，用文件接口来完成设备的操作 2.一个完成linux的设备驱动程序的结构：1）.设备打开2）.释放3）.读写操作4）.控制操作5）.中断和轮询处理6）.驱动程序的注册和注销 3.简单字符设备驱动程序的例子： 定义5个接口 static int my_open(struct inode * inode,struct file * filp){ //设备打开的操作 MOU_INC_USE_COUNT; //增加引用计数 return 0; } static int my_release(struct inode* inode,struct file * filp){ //设备关闭时的操作 MOU_DEC_USE_COUNT; return 0; } static int my_write(struct file *file,const char* buffer,size loff_t *ppos){ //设备写入时的操作 char led_status = 0; copy_from_user(&amp;let_status,buffer,sizeof(led_status)); //从用户态到内核态 if(led_tatus ==0x01){ AT91F_PIOB_SetOutput(LED) }else{ AT91F_PIOB_ClearOutput(LED) } return 0; } static int my_init(void){ //设备的注册：硬件初始化，注册设备，创建设备节点 //硬件初始化 AT91F_PIOB_Enable(LED); //字符设备注册 Led_Major = register_chrdev(0,DEVICE_NAME,&amp;my_fops); //创建设备文件 Devfs_Led_Dir = devfs_mk_dir(NULL,”my_led”,NULL); Devds_Led_Raw = devfs_register(Devfs_Led_Dir,”0”,DEVFS_FL_DEFAULT,Led_Major,1,S_IFCHR|S_IRUSR|S_IWUSR,&amp;my_fops,NULL); } static void my_exit(void){ //设备的注销：删除设备节点，注销设备... //删除设备文件 devfs_unregister(Devfs_Led_Raw); devfs_unregister(Devfs_Led_Dir); //注销设备 unregister_chrdev(Led_Major,DEVICE_NAME); } moudle_init(my_init);设备注册的登记 moudle_exit(my_exit);//设备注销的登记 文件操作有国际意义的结构体定义，里面的参数不是每一个都会用到以上使我们自定义的函数，需要把我们自定义的函数和标准的文件架构关联起来 static struct file_operations my_fops{ open: my_open; write:my_write; release:my_release; } 最终make之后生成my_led.o的驱动程序 驱动程序插入内核： insmod my_led.o 查看是否载入: cat /proc/devices 移除： rmmod my_led 测试驱动应用程序 int main(void){ int fd; char led_on = 1; fd = open(“/dev/my_led”,O_RDWR); write(fd,&amp;led_on,1); close(fd); return 0; } 文件系统连续文件 索引文件 串联文件例如FAT文件（FAT12 FAT16 FAT32 ）将next 集中顺序放在FAT表中若存储块有2^N块， FAT有2^N个元素，每项至少需要N位宽度扇区：磁盘上最小寻址存储单元 512 字节簇：存储块，设备的最小 存取单元FAT元素的数目和簇测的数目一样磁盘容量= FAT长度簇容量=FAT长度簇扇区数*512 存储空间管理空闲文件目录把连续空闲看成特殊文件，由多个连续空闲块组成 空闲块链把空闲块链接在一起 ，当申请空闲块时，链头开始搜索所需空闲块，当回首空闲块时，把释放的空闲块加载链位 位示图","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"OSPrinciple","slug":"OSPrinciple","date":"2020-04-02T07:30:09.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/04/02/OSPrinciple/","link":"","permalink":"/2020/04/02/OSPrinciple/","excerpt":"","text":"操作系统原理分析 操作系统功能1.进程管理（CPU管理）进程控制：创建，暂停，唤醒，撤销进程调度：调度策略，优先级进程通信 2.内存管理内存分配，共享，保护，虚拟内存 3.设备管理设备的分配，调度，设备传输，设备驱动 4.文件管理存储空间，文件目录的操作，存取权限的管理 分时技术（Unix）交互性，响应性多终端计算机（一个主机下面有很多终端，共享主机的CPU资源，主机以很短的时间片为单位，把CPU轮流的分配给终端使用，直到全部作业运行完）多路调制性（多用户联机使用同一台计算机）独占性（每个终端感觉自己独占CPU）交互性（及时响应用户请求） OS的逻辑结构整体式结构以模块化，编码调试相对独立，调用自由，同行以全局变量形式完成 层次式结构相邻层只有单向依赖或者单向调用（结构清晰 有利于移植，维护，扩充） 微内核结构微内核（最核心的服务）+核外服务器（进程，设备管理服务器等） CPU态：（对资源和使用权限的描述） 核态：能够访问所有资源额执行的所有指令；管理程序OS内核 用户态：访问资源受限。用户程序 在硬件层是以“态”区分在CPU层是以“进程”区分 存储器 中断 引入中断的目的：1.实行并发活动（CPU和外设）2.实行实时处理3.故障自动处理 中断响应过程：1.识别中断源2.保护断点和线程3.装入中断服务程序的入口地址（cs:ip）4.进入中断程序5.恢复现场和断点6.中断返回（IRET） 中断的实质：交换指令执行地址交换CPU的态 工作模式实模式 保护模式 BIOS功能系统启动配置基本的设备I/O服务系统的加电自检和启动 按下电源键计算机执行第一条指令是FFFF0的指令(JUMP POST )——&gt;加电自检 (POST )——&gt;初始化CPU、内存、显卡(查找显卡BIOS，调用显卡BIOS，一次查找其他设备的BIOS)——&gt;显示启动画面——&gt;从硬盘、U盘、光驱等读取OS——&gt;OS 启动，OS接管计算机 启动过程1.初始引导（BIOS启动程序，加载MBR的引导程序—GRUB，加载内核OS）2.核心初始化3.系统初始化 主启动记录（MBR）存放在硬盘的首扇区，存放OS启动相关信息，512 bytes,结束：0XAA55h每个分区的首扇区记录主启动记录；主启动扇区：提供菜单（选择不同的OS）；加载核心文件（指向可启动的OS）；跳转（将启动功能交给其他的loader） BIOS和MBR程序运行过程： 用户界面1.操作界面图形用户接口；键盘命令：普通命令，批处理程序，shell 2.系统调用 有唯一的ID 进程管理进程状态运行态:进程占有CPU就绪态：具备运行条件无CPU，暂时不能运行阻塞态：等待某项服务完成或者信号不能运行，等待外设完成相应的I/O操作，等待其他进程给他提供信号 Linux进程的状态 进程控制块PCB是一种描述进程状态，资源，相关进程的数据结构主线程是缺省出来的 忙则等待：当临界区忙，其他进程必须在临界区外等待空闲让进：当没有进程在临界区，任何进程有权进入临界区有限等待：待进入临界区的进程应该有限时间内得到满足让权等待：当在等待进入临界区的进程放弃CPU临界区越小越好 互斥：多个进程共享了独占性资源，确保没有任何两个以上的进程同时进行存取操作同步：合作进程需要满足先后关系，一个进程能否进行取决于某个前提条件，否则只能等待（公交车和售票员） 信号灯进程在运行过程中受信号灯状态的控制，并能改变信号灯状态 P操作用二元矢量表示（S,q） S整数，初始非负，信号量 q PCB队列P操作可能会使进程在调用出阻塞 S初始值很重要 V操作V操作可能会唤醒阻塞的进程 P-V操作解决互斥问题 Q-V操作解决同步问题 生产者消费者同步控制问题 Windows同步机制临界区机制（CREARTE_SECTION）：临界资源的访问（允许一个）EnterCriticalSectionLeaveCriticalSection 互斥量机制跨进程使用（允许一个）CreateMutex 信号量机制允许多个线程/进程访问临界区 并发访问资源WaitForSingleObject()减一ReleaseSemaphore()加一信号量的值大于0 有信号 小于等于0 无信号 事件机制Linux父子进程 父进程等待——&gt;子进程——&gt;exit()——&gt;父进程善后子进程,收回资源，撤回PCB信息。pid_2获取的是子进程的pid_1——&gt;exit() 父子进程共享普通变量int i = 1 即使先运行子进程i= 2，在运行父进程i,他们互不影响。输出子进程i =2;父进程i=1;父子进程共享文件资源父子进程共享同一文件和读写指针。子进程写入，父进程写入 ，最终会一起写入 Windows匿名管道通信仅能用于父子或者兄弟进程通信 1.父进程创建两个管道CreatePipe2.父进程创建子进程CreateProcess3.父进程写入管道14.父进程读取管道2 Linux信号通信机制信号的来源1.键盘输入组合键2.终端命令3.调用函数4.硬件或者内核异常Linux定义了64 中信号编号1——64 父进程fork子进程，发送（kill）自定义信号SIGUSR1，子进程注册信号signal指向handler处理相应要求，exit，然后执行父进程 死锁两个或者多个进程无限期的等待永远不会发生的条件的状态结果没个进程都陷入阻塞 死锁的原因1.系统资源有限,但是系统资源有限不一定会发生死锁2.并发进程推进顺序不当 进程请求释放资源顺序不当 假设A先运行 当运行到第5行时，运行B，此时j 被占用B在第二行阻塞，然后返回A知道第7行之后被释放继续运行B，并没有导致死锁 假设A先运行，当运行到第4行时，运行B，B在第4行j 被占用阻塞，使用i，i被占用进程A也被阻塞，导致死锁 3.不正确的P-V操作也会带来死锁（消费者和生产者例子的P-V顺序使用不当） 死锁的必要条件1.互斥条件：进程互斥使用资源，资源具有独占性2.不剥夺条件：进程访问资源前，不被其他进程强行剥夺3.部分分配条件：临时需要临时分配4.环路条件 解决死锁的策略1.预防死锁 通过设置某些条件，破坏死锁的必要条件 由于限制太严格，资源利用率低2.避免死锁 若分配资源是否会让系统进入死锁状态，是，拒绝分配资源。很难实现3.检测恢复死锁 先检测恢发生死锁，然后清除死锁 实现难度大4.预先静态分配法 破坏部分分配条件：运行进程前，将所需资源一次性全部分配 开销大，利用率低，延迟5.有序资源分配 破坏环路条件 给每个资源分配一个序号；进程每次申请资源时，只能申请序号更大的资源 ●按有序资源分配法分配资源并发进程不会发生死锁（序号递增）●操作系统没有死锁解决方案，留给用户解决 进程调度算法1.先来先服务只考虑时间，不利于短作业2.短作业优先调度算法不利于长作业，易出现饥饿现象3.响应比高优先调度算法响应比=1+等待时间/运行时间，有利于短作业或者长作业（兼顾）4.优先数调度算法优先数=静态优先数+动态优先数静态：进程所需资源；运行时间长短；进程的类型（IO/CPU，前台/后台，核心/用户）动态：使用CPU超过一定时长时（大进程降低优先数）；当进行I/O操作后（增加优先数）；当进程等待时间超过一定时间后（增加优先数）5.循环轮转调度算法先进先出排成队列，进程以时间片段q轮流使用CPU，队列逻辑上形成环形公平性：每个进程都平等的有机会获得CPU交互性：每个进程等待（N-1）*q的时间可以重新获得CPU若q太大相当于先来先服务若q太小进程切换频繁，系统开销大 Linux进程调度普通进程：采用动态优先级。进程占用CPU，优先级随时间流失减小 task_struct 的counter表示动态优先级实时进程：静态优先级。 进程创建时指定或者优用户修改 先进先出 时间片轮转 新建子进程counter从父进程时间片counter中继承一半 进程调度不同的进程有不同的调度需求（linux中进程优先级是动态的）进程调度时机（schedule函数内核函数，用户态不能直接调用schedule）：中断处理过程（包括时钟中断、IO中断、系统调用、异常）中,直接调用schedule；或者返回用户态时根据need_resched标记调用schedule内核线程（是一个没有用户态只有内核态的特殊的进程，没有系统调用但可以发生中断，在发生中断的时候可以调用schedule）可以直接调用schedule进行进程切换。用户态无法主动调度，只能通过陷入内核状态后的某个时机进行调度，即中断处理过程中 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上执行的进程，并且恢复以前挂起的某个进程的执行进程上下文包含了进程执行需要的所有信息： 1.用户地址空间（代码，数据，用户堆栈等）2.控制信息（进程描述符，内核堆栈）3.硬件上下文 Schedule函数选择新的进程来运行，调用context_switch进行切换，这个宏调用switch_to (prev指向当前进程，next指向被调度的进程) 下一篇继续记录（来自华中科技大学操作系统原理学习）","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"PandArray","slug":"PandArray","date":"2020-03-31T03:46:55.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/03/31/PandArray/","link":"","permalink":"/2020/03/31/PandArray/","excerpt":"","text":"char *str1 = &quot;lilei&quot;; //(1) char str2[] = &quot;lilei&quot;; //(2) 这里是定义，不是声明，因为两个字符串都分配了空间（1）是一个指针变量 保存在字符串常量区不能被修改，（2）是一个数组 #include &quot;stdio.h&quot; #include &quot;stdlib.h&quot; #include &quot;string.h&quot; int main(void) { char *str1 = &quot;lilei&quot;; char *str3 = &quot;lilei&quot;; char str2[] = &quot;lilei&quot;; memcpy(str1,&quot;hello&quot;,strlen(&quot;hello&quot;)+1); //向一个非法的地址拷贝东西，错误 str1[1] = &#39;a&#39;; //错误 操作非法的地址 str2[1] = &#39;a&#39; //允许 printf(&quot;str1:%s str3:%s\\n str2:%s\\n&quot;,str1,str3,str2); str3 = &quot;world&quot;; //指针变量保存的地址是可以变化的 str3的值会变成world printf(&quot;str1:%s str3:%s str2:%s\\n&quot;,str1,str3,str2); printf(&quot;hello,world\\n&quot;); return (0); } #include &lt;stdio.h&gt; #include &quot;stdlib.h&quot; #include &quot;string.h&quot; const int a = 1; const int a1 = 1; char * s = &quot;hello&quot;; int main() { const int b = 2; const int b1 = 2; char * s1 = &quot;hello&quot;; printf(&quot;s:%p s1:%p\\n&quot;,s,s1); printf(&quot;a:%p a1:%p b:%p b1:%p\\n&quot;,&amp;a,&amp;a1,&amp;b,&amp;b1); return 1; } 输出 s:0000000000404008 s1:0000000000404008 a:0000000000404000 a1:0000000000404004 b:000000000062FE14 b1:000000000062FE10 -------------------------------- s,s1,a,a1在一个内存区域。这个内存区域的内容是不允许改变的。 对于以上代码 const int b = 2; int main() { const int b1 = 2; int *p = &lt;font color=red&gt;&amp;b1&lt;/font&gt;;; printf(&quot;b1:%d\\n&quot;,b1); *p = 3; printf(&quot;b1:%d\\n&quot;,b1); //输出 b1=2 b1 = 3 const int b1 = 2; int *p = &lt;font color=red&gt;&amp;b&lt;/font&gt;; printf(&quot;b:%d\\n&quot;,b); *p = 3; //错误 printf(&quot;b:%d\\n&quot;,b); //输出 b1=2 return 1; }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"CPPInterview","slug":"CPPInterview","date":"2020-03-30T02:44:57.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/03/30/CPPInterview/","link":"","permalink":"/2020/03/30/CPPInterview/","excerpt":"","text":"分享别人的C++面试问题 gdb调试命令step和next的区别当前line有函数调用的时候,next会直接执行到下一句（F11）,step会进入函数（F10）。 查看内存$(gdb)p &amp;a //打印变量地址 $(gdb)x 0xbffff543 //查看内存单元内变量 $0xbffff543: 0x12345678 $(gdb)x/4xb 0xbffff543 //单字节查看4个内存单元变量的值 $0xbffff543: 0x78 0x56 0x34 0x12 } 多线程调试$(gdb) info threads：查看GDB当前调试的程序的各个线程的相关信息 $(gdb) thread threadno：切换当前线程到由threadno指定的线程 $break filename:linenum thread all 在所有线程相应行设置断点，注意如果主线程不会执行到该行，并且启动all-stop模式，主线程执行n或s会切换过去 $set scheduler-locking off|on\\step 默认off，执行s或c其它线程也同步执行。on，只有当前线程执行。step，只有当前线程执行 $show scheduler-locking 显示当前模式 $thread apply all command 每个线程执行同意命令，如bt。或者thread apply 1 3 bt，即线程1，3执行bt。 查看调用堆栈$(gdb)bt $(gdb)f 1 帧简略信息 $(gdb)info f 1 帧详细信息 断点b test.cpp:11 b test.cpp:main gdb attach 调试方法： gdb-&gt;file xxxx-&gt;attach pid-&gt;这时候进程是停止的-&gt;c 继续运行 带参数调试输入参数命令set args 后面加上程序所要用的参数，注意，不再带有程序名，直接加参数，如： (gdb)set args -l a -C abc list命令list linenum 显示程序第linenum行的周围的程序 list function 显示程序名为function的函数的源程序 软硬链接ln -s 源文件 目标文件, ln -s / /home/good/linkname链接根目录/到/home/good/linkname 1、软链接就是：“ln –s 源文件 目标文件”，只会在选定的位置上生成一个文件的镜像，不会占用磁盘空间，类似于windows的快捷方式。2、硬链接ln源文件目标文件，没有参数-s， 会在选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 函数指针函数指针 int (*func)(int, int) 函数指针数组 int (*funcArry[10])(int, int) const int* p; 指向const int的指针 int* const p; const指针 设计模式单例模式一对一● 1、单例类只能有一个实例。● 2、单例类必须自己创建自己的唯一实例。● 3、单例类必须给所有其他对象提供这一实例。比如：● 1、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。● 2、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 观察者模式一对多● (也叫发布订阅模式)当一个对象被修改时，则会自动通知它的依赖对象 工厂模式三种：简单工厂模式、工厂方法模式、抽象工厂模式 为什么要用工厂模式？原因就是对上层的使用者隔离对象创建的过程；或者是对象创建的过程复杂，使用者不容易掌握；或者是对象创建要满足某种条件，这些条件是业务的需求也好，是系统约束也好，没有必要让上层使用者掌握，增加别人开发的难度。所以，到这时我们应该清楚了，无论是工厂模式，还是开闭原则，都是为了隔离一些复杂的过程，使得这些复杂的过程不向外暴露，如果暴露了这些过程，会对使用者增加麻烦，这也就是所谓的团队合作。 大小端转化 #define BigLittleSwap32(A) ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24)| \\ (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8) | \\ (((uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8) | \\ (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24)) IO多路复用为什么 IO 多路复用要搭配非阻塞IOselect和read两个操作相互独立且存在窗口，select返回可读并不能保证read一定可读，存在多种情况，select返回可读，但是read无数据可读● 多进程同时对某个socket进行监听，当新的连接完成3次握手后，进程均被select,epoll唤醒，但是最后只有1个进程可以accept，没能accept的进程被block● 某个socket接收缓冲区有新数据分节到达，然后select报告这个socket描述符可读，但随后，协议栈检查到这个新分节检验和错误，然后丢弃这个分节，这时候调用read则无数据可读● 边缘触发环境，由于无法知道多少数据可读，所以accept1次后，第二次尝试accept可能会被阻塞，此时应该使用非阻塞IO 设置非阻塞 io fcntl(sockfd, F_SETFL, O_NONBLOCK);","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"Lifetink","slug":"Lifetink","date":"2020-03-30T02:36:01.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/03/30/Lifetink/","link":"","permalink":"/2020/03/30/Lifetink/","excerpt":"","text":"热爱生活热爱自己热爱技术加入生活辜负了你，却不要辜负生活","categories":[{"name":"think","slug":"think","permalink":"/categories/think/"}],"tags":[],"keywords":[{"name":"think","slug":"think","permalink":"/categories/think/"}]},{"title":"Test","slug":"Test","date":"2020-03-29T06:59:14.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/03/29/Test/","link":"","permalink":"/2020/03/29/Test/","excerpt":"","text":"很高兴您访问raylee,和我一起学习吧！ 不可重入函数:$ Int g=0; $ Int function(){ $ g++; //执行另一个线程执行 $ printf(“%dg值：” g); }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"newTest","slug":"newTest","date":"2020-03-28T12:54:04.000Z","updated":"2020-08-12T02:59:38.000Z","comments":true,"path":"2020/03/28/newTest/","link":"","permalink":"/2020/03/28/newTest/","excerpt":"","text":"很高兴您访问raylee,和我一起学习吧！ 不可重入函数:$ Int g=0; $ Int function(){ $ g++; //执行另一个线程执行 $ printf(“%dg值：” g); }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]}]}