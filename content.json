{"meta":{"title":"raylee","subtitle":null,"description":"raylee personal blog","author":"raylee","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-29T05:50:52.469Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Hello,raylee] 与&nbsp; raylee&nbsp; （ Love greetings ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-29T06:00:03.342Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-04-03T07:54:51.966Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-29T06:02:03.295Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"resume","date":"2018-12-20T15:13:35.000Z","updated":"2020-04-03T08:16:05.279Z","comments":false,"path":"download/index.html","permalink":"/download/index.html","excerpt":"","text":"点击下载查看","keywords":"我的简历"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2020-03-28T15:11:06.000Z","updated":"2020-03-29T06:07:38.864Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-29T06:08:50.911Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-28T14:14:16.000Z","updated":"2020-03-29T05:47:29.754Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-29T06:13:23.978Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"S32V234","slug":"S32V234","date":"2020-04-08T09:14:47.000Z","updated":"2020-04-08T10:33:37.287Z","comments":true,"path":"2020/04/08/S32V234/","link":"","permalink":"/2020/04/08/S32V234/","excerpt":"","text":"S32V234StudyS32VS32V234 相关硬件架构&amp;相关术语 S32V234 S32V 基础概念及名词解释 S32V environmentS32V234 Soc linux环境搭建&amp;BSP制作 S32V234 用 Visual Studio Code 搭建 S32V234 编译环境 SensorS32V234 摄像头与光学 | Camera 信号波形状态总结及同步方式 S32V234 摄像头与光学 | 摄像头基本知识 S32V234 摄像头与光学 | SENSOR &amp; ISP 简介及 Tuning Guide S32V234 SerDes + OV Sensor 驱动调试 S32V234 摄像头驱动调试 APEXS32V234 APEX 架构介绍 S32V234 APEX 数据组织和具体的处理流程 S32V234 Linux环境的 APEX 范例编译 S32V234 如何运用 ApexCV Library 建立第一支程式 (Linux 编程) S32V234 S32DS 中新建 Kernel 算子并编译（上） S32V234 S32DS 中新建 Kernel 算子并编译（下） ISPS32V234 ISP Graph 创建实例 S32V234 S32DS 构建graph S32V234 ISP中Debayer是什么 S32V234 ISP Demo 程序创建及运行 S32V234 ISP Graph 的动态调度和静态调度 on S32DS S32V234 如何抓取图像的 Buffer 进而分析 S32V234 ISP kernel 设计指南 S32V234 ISP kernel 设计指南 2 S32V234 如何从无到有完成 ISP kernel 算子的参数调整（上） S32V234 如何从无到有完成 ISP kernel 算子的参数调整（下） CANCAN协议 S32V234 CAN总线通信测试 进程通信 ARMS32V234 ARM 中 NEON 使用 Hands on (上) S32V234 ARM 中 NEON 使用 Hands on (下) ADASS32V234 构建ISP_APEX ADAS GPU driverS21V234 GPU驱动编译 BSPS32V234 Yocto 搭建系统平台 S32V234 ARM 中 NEON 使用 Hands on (上) S32V234 ARM 中 NEON 使用 Hands on (下) S32V234 优化 S32V Yocto BSP &amp; VSDK 环境搭建流程 S32V234 手动制作NFS方式启动 initramfs 调试 S32V234 CSE 模块相关介绍 S32V234 U-boot 环境变量初始化 DCUS32V234 DCU &amp; FrameBuffer Hands On Memory Stress TestS32V234 S32V234 Memory Stress Test（上） S32V234 S32V234 Memory Stress Test（下） S32V FAQS32V234 移植 S32DS_Vision_v2.0 Sample Code 至 Linux 上开发 S32V234 Ubuntu16.04 中 S32DS 的 APEX 工程无法仿真","categories":[{"name":"link","slug":"link","permalink":"/categories/link/"}],"tags":[],"keywords":[{"name":"link","slug":"link","permalink":"/categories/link/"}]},{"title":"ComputerNet","slug":"ComputerNet","date":"2020-04-03T08:50:18.000Z","updated":"2020-04-03T11:17:41.241Z","comments":true,"path":"2020/04/03/ComputerNet/","link":"","permalink":"/2020/04/03/ComputerNet/","excerpt":"","text":"计算机网路概述局域网(LAN)● 同一网络下，不同计算机使用的是局域网，覆盖范围小，自己花钱买设备，贷款固定，自己维护 广域网（WAN）● 链接不同地区的局域网，形成一个大范围的网络 数据通讯过程客户端到服务器端发生了什么？ 图片1 每个计算机有自己的IP和mac地址（计算机的物理地址），子网掩码255代表网络部分，0代表主机部分当我们在浏览器输入URL时，DNS把我们的域名解析成相应URL 网页存放的IP地址，此时访问计算机就知道被访问的IP地址。 数据包：包括数据和本机ip 和目标ip data 本机IP 目标IP 数据 12.0.0.1 17.0.0.2 数据帧：数据包加上本机和目标服务器的mac地址 data 本机IP 目标IP 本机mac 目标mac 数据 12.0.0.1 17.0.0.2 mac本机 mac目标 往下传播时，更新数据帧mac 地址，去找到最终存放网页数据IP计算机，A—F—D—H。服务器收到客户端的请求之后，会反馈给客户端，首先，服务器把网页切割成小的数据包，一个一个放入缓存区里面，传一个给客户端之后，客户端收到数据，再反馈服务器端传下一个数据包（若果客户端不给反馈，服务器端会重新再发一个数据包 ），更新缓存区，知道数据接收完为止。 数据通讯的OSI模型●应用层：所有能产生网络流量的应用程序●表示层：在传输之前是否进行加密或者压缩 （二进制、ASCLL）●会话层：查看传输过程中的木马 netstat -n, 是否存在其他病毒干扰传输●传输层：可靠传输，流量控制，不可靠传输（直接传输，客户端直接到达DNS传输）●网络层：负责选择最佳路径，规划IP地址●数据链路层：帧的开始和结束，透明传输，差错校验●物理层：接口标准，电器压标准，如何在物理链路上传输更快","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"OS_MemoryManagement","slug":"OS-MemoryManagement","date":"2020-04-02T12:21:30.000Z","updated":"2020-04-03T08:53:58.151Z","comments":true,"path":"2020/04/02/OS-MemoryManagement/","link":"","permalink":"/2020/04/02/OS-MemoryManagement/","excerpt":"","text":"存储管理存储器功能容量大、速度快、信息永久保存、多道程序并行（共享，保护） 内存管理功能地址映射把程序的地址（虚拟地址/逻辑地址/虚地址），变换为内存中真实的地址（实地址/物理地址） 地址映射有三种方式： 1.固定地址映射（编程时直接使用物理地址或者通过编译器映射物理地址 ）2.静态地址映射（程序装入时由操作系统完成逻辑到物理的过程，装入时是指：双击图标时/终端输入命令回车时）物理地址（MA）=逻辑地址（VA）+装入基址（BA） MA = X + BA●程序运行之前确定映射关系●程序装入后不能移动●程序占用连续空间 3.动态地址映射程序在执行过程中将逻辑转化为物理地址内存占用空间可动态变化程序不用占用连续的内存空间便于多个进程共享代码 虚拟存储内存分配分配空间 存储保护防止越界或者越权。采用界址寄存器，在CPU中设置一对上限寄存器和下限寄存器存储程序在内存中的上限和下限 物理内存管理单一区存储分区存储1.固定分区（找合适的分区运行） 2.动态分区（存在空间碎片） 空闲区放置策略 1.分区回收（释放与现有空闲区相邻，先合并再更新空闲区，不相邻直接插入空闲区）2.内存覆盖技术 用较小的空间运行较大的程序有常驻区和覆盖区编程复杂程序执行时间变长：从外存装入内存耗时 3.内存交换技术内存不够时把进程写入磁盘，运行时再换回内存要运行B 先换出A，运行B。当要运行A的时候再把A换回内存。此时A放入内存的什么位置？（1）.放到原来的位置：简单，可能会造成地址冲突（2）.放到任意位置，灵活运用内存，地址需要重定位 解决碎片问题1.规定门限值，分割空闲区域时，若剩余部分小于门限值，不分割，全部分配给用户2.内存拼接技术：将所有空闲区集中构成一个大的空闲区（消耗资源系统，离线拼接，重新定义作业）(1)在释放回收的时候：频率大，内存开销大(2)系统找不到空间的时候：空闲区管理(3)定期：空闲区管理3.解除程序占用连续内存才能运行的限制 虚拟内存●物理内存有以下几种缺点：源程序知直接使用内存的物理地址，程序访问容易引起冲突程序必须全部装入内存才能运行，内存小而不能满足程序占有连续的一片内存，产生内存碎片多程序同事运行相互干扰 虚拟内存使得较大的和多个程序在小的内存中运行多个程序并发运行地址不冲突内存利用率高，无碎片 实现思路程序运行时，只把当前必要的很小一部分代码和数据装入内存，其余的需要的时候再装入，不运行的代码和数据及时从内存中删除 典型的虚拟内存管理方式页式虚拟内存管理 只把程序部分页装入内存中便可运行页在内存中占用页框不比相邻需要页时按需从硬盘中调入内存不运行的页，及时删除 1.页式地址映射虚拟地址（VA）可以分解成页号（P）和页内偏移（W）若页的大小（2^n）P = VA / 页的大小 = VA &gt;&gt; nW= VA %页的大小 =低n位 = VA&amp;&amp;（2^n -1）由于页是直接平移到页框上，他们直接的对应关系使用页表记录 虚拟地址（页式）——&gt; 物理地址1).从VA中分离P和W2).查页表，搜索某个页号P在页框中的索引P13).某个页号物理地址MA = P1 * X页的大小 +W 2.块表机制（cache）慢表：页表放在内存中快表：页表放在cache中快表容量小，访问快，他是慢表的部分内容复制；地址映射优先访问快快表，若快表中找到所虚的数据，叫命中，若果没有命中需要访问慢表，然后在更新快表。 普通页表采用软件对比，快表采用硬件对比 3.页面的共享可以节省空间。比如Windows系统的动态链接库是程序共享的 不同的进程有相同的页框号，多个进程访问相同的内存 在页表中加入中断位，用来标识页是否在内存中，不在内存用1 ；在，用0标识。在页表中加入访问位和修改位，0未修改，未访问；1 修改过，访问过缺页中断，在地址映射过程中，所访问的目的也不在内存中，则系统产生异常中断（缺页中断）缺页中断程序，把所缺的页从辅存调入内存中的某个页框，并更某个页框号，修改中断位为0访存指令： 缺页率 = 缺页次数/访问页面总次数 4.页面淘汰算法页面在内存和辅存之间频繁交换叫做抖动1).最佳算法（OPT）淘汰以后不再需要或者最远的将来才会用到的页面理想状态，无法实现 2).先进先出淘汰算法（FIFO）淘汰在内存中停留时间最长的页面实现简单，但是进程只有按顺序访问地址空间时，页面命中率才很理想，随着页框数增加，缺页率反而增加 3).淘汰最长时间未被使用的页面（LRU）通过移位寄存器来实现，每个页面被访问则将其重置1，周期性的左移，记录值。 4).最不经常使用算法（LFU）访问次数最少的淘汰 5.缺页的因素●淘汰算法●分配的页框数（页框越少，越容易缺页）●页本身的大小（页面越小，越容易缺页）●程序的编制方法●由于局部性原理，上面的程序运行效率更好，二维数组按行存储，下面按列遍历会产生跳转，会导致更高的缺页率，局部性差 6.页式系统的不足页面划分无逻辑页的共享不灵活页内碎片 段式存储管理把进程按逻辑意义划分多个段，一段为单位，每个段连续存储，每个段间是独立的，段与段间不相邻段式虚拟地址（VA）有段号，段内偏移（W） 段表 记录段号（S），段长（L），该段的在内存的基地址即基地址（B） MA = B+W0≤W≤L 1.段氏缺点段需要连续存储段的最大尺寸收到内存大小的限制在辅存中管理可变尺寸的段比较困难 2.段与页的区别段长可变 ，页面大小固定段的划分有意义，页的划分无意义段方便共享，页面共享不方便段是程序员划分的，页面用户不可见段偏移有溢出，页面无偏移溢出 段页式存储管理段中划分页面 段页式地址映射过程 Intel CPU的物理结构实模式20 位，1M内存空间地址表示方式：段地址（16位）+偏移地址（16位）直接存储物理地址 保护模式32位，4G内存多增加新的寄存器 ●开机从实模式转到保护模式 控制寄存器CR0：PE位：0实模式；1 保护模式PG允许分页 控制器CR2：保存缺页的线性地址控制器CR3：页目录的基址 逻辑地址在实模式下是段基址+偏移值逻辑地址在保护模式下段选择子+偏移值 段与段描述符 描述符数据结构（段基址：32位 段界限： 20 位）描述符表里面放的描述符 描述符表的类型全局描述符（GDT）：包含所有进程 的段描述符局部描述符（LDT）：特定进程有关的描述符中断描述符（IDT）：包含中断服务程序段描述符 选择子 Linux三级页表结构将4M的超大页表存储到1K个页框中。页表按需调入内存 Linux段机制用户空间：3G 0—0xBFFFFFFF内核空间：1G 0xC0000000—0xFFFFFFFF进程创建时，段机制对寄存器初始化 ●内核特权级为0●用户特权级为3 作用●利用段机制隔离用户数据和系统数据●简化逻辑到线性地址的转化，可直接将虚拟地址当做线性地址 下一篇继续记录（来自华中科技大学操作系统原理学习）","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"OS_FileManagement","slug":"OS-FileManagement","date":"2020-04-02T12:20:33.000Z","updated":"2020-04-02T13:17:37.567Z","comments":true,"path":"2020/04/02/OS-FileManagement/","link":"","permalink":"/2020/04/02/OS-FileManagement/","excerpt":"","text":"设备管理主要功能1.设备分配共享设备分配（包括所有的块设备，多进程交替使用同一设备。例如磁盘）独占设备分配（包括所有的字符型设备，任意时间内最多被一个进程占用，例如：键盘，打印机）使用过程：申请——》使用——》释放虚拟分配在一类物理设备上模拟另一类物理设备，虚拟光驱 借助辅存部分区域模拟独占设备，将独占设备转化为共享设备；当进程需要与独占设备交换信息时，就采用虚拟技术将与该独占设备所对应的虚拟设备分配给他例如SPOOLing系统(外部设备同时联机操作) 2.设备映射：逻辑设备映射到物理设备 3.设备驱动：对物理设备进行控制实现I/O操作；接受应用的服务请求；向用户提供统一接口 设备驱动程序的特点:●它与硬件相关●每一类的设备都有特定的驱动程序●驱动程序一般由厂商根据操作系统要求编写●操作系统仅对设备驱动的接口提出要求 Linux内核模块（解决单体内核机制的不足）未经链接的可执行代码经过装载成为内核的一部分然后动态的装载和卸载 编译模块： gcc -o xxmoudle.ko _D_KERNEL_ -MOUDLE xxx.c 安装: sudo insmod xxmoudle.ko 还可以带参数（Sudo insmod xxmoudle.ko str = “xxx” intval = 4） 删除模块： sudo rmmod moudle 查看内核信息: dmesg 查看模块： Lsmod Linux驱动程序驱动程序工作在内核态 1.驱动设备分为：字符设备(执行ls -L/dev c)块设备（b）网络设备（socket） 硬件设备都可看成设备文件，用文件接口来完成设备的操作 2.一个完成linux的设备驱动程序的结构：1）.设备打开2）.释放3）.读写操作4）.控制操作5）.中断和轮询处理6）.驱动程序的注册和注销 3.简单字符设备驱动程序的例子： 定义5个接口 static int my_open(struct inode * inode,struct file * filp){ //设备打开的操作 MOU_INC_USE_COUNT; //增加引用计数 return 0; } static int my_release(struct inode* inode,struct file * filp){ //设备关闭时的操作 MOU_DEC_USE_COUNT; return 0; } static int my_write(struct file *file,const char* buffer,size loff_t *ppos){ //设备写入时的操作 char led_status = 0; copy_from_user(&amp;let_status,buffer,sizeof(led_status)); //从用户态到内核态 if(led_tatus ==0x01){ AT91F_PIOB_SetOutput(LED) }else{ AT91F_PIOB_ClearOutput(LED) } return 0; } static int my_init(void){ //设备的注册：硬件初始化，注册设备，创建设备节点 //硬件初始化 AT91F_PIOB_Enable(LED); //字符设备注册 Led_Major = register_chrdev(0,DEVICE_NAME,&amp;my_fops); //创建设备文件 Devfs_Led_Dir = devfs_mk_dir(NULL,”my_led”,NULL); Devds_Led_Raw = devfs_register(Devfs_Led_Dir,”0”,DEVFS_FL_DEFAULT,Led_Major,1,S_IFCHR|S_IRUSR|S_IWUSR,&amp;my_fops,NULL); } static void my_exit(void){ //设备的注销：删除设备节点，注销设备... //删除设备文件 devfs_unregister(Devfs_Led_Raw); devfs_unregister(Devfs_Led_Dir); //注销设备 unregister_chrdev(Led_Major,DEVICE_NAME); } moudle_init(my_init);设备注册的登记 moudle_exit(my_exit);//设备注销的登记 文件操作有国际意义的结构体定义，里面的参数不是每一个都会用到以上使我们自定义的函数，需要把我们自定义的函数和标准的文件架构关联起来 static struct file_operations my_fops{ open: my_open; write:my_write; release:my_release; } 最终make之后生成my_led.o的驱动程序 驱动程序插入内核： insmod my_led.o 查看是否载入: cat /proc/devices 移除： rmmod my_led 测试驱动应用程序 int main(void){ int fd; char led_on = 1; fd = open(“/dev/my_led”,O_RDWR); write(fd,&amp;led_on,1); close(fd); return 0; } 文件系统连续文件 索引文件 串联文件例如FAT文件（FAT12 FAT16 FAT32 ）将next 集中顺序放在FAT表中若存储块有2^N块， FAT有2^N个元素，每项至少需要N位宽度扇区：磁盘上最小寻址存储单元 512 字节簇：存储块，设备的最小 存取单元FAT元素的数目和簇测的数目一样磁盘容量= FAT长度簇容量=FAT长度簇扇区数*512 存储空间管理空闲文件目录把连续空闲看成特殊文件，由多个连续空闲块组成 空闲块链把空闲块链接在一起 ，当申请空闲块时，链头开始搜索所需空闲块，当回首空闲块时，把释放的空闲块加载链位 位示图","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"OSPrinciple","slug":"OSPrinciple","date":"2020-04-02T07:30:09.000Z","updated":"2020-04-02T12:50:41.282Z","comments":true,"path":"2020/04/02/OSPrinciple/","link":"","permalink":"/2020/04/02/OSPrinciple/","excerpt":"","text":"操作系统原理分析 操作系统功能1.进程管理（CPU管理）进程控制：创建，暂停，唤醒，撤销进程调度：调度策略，优先级进程通信 2.内存管理内存分配，共享，保护，虚拟内存 3.设备管理设备的分配，调度，设备传输，设备驱动 4.文件管理存储空间，文件目录的操作，存取权限的管理 分时技术（Unix）交互性，响应性多终端计算机（一个主机下面有很多终端，共享主机的CPU资源，主机以很短的时间片为单位，把CPU轮流的分配给终端使用，直到全部作业运行完）多路调制性（多用户联机使用同一台计算机）独占性（每个终端感觉自己独占CPU）交互性（及时响应用户请求） OS的逻辑结构整体式结构以模块化，编码调试相对独立，调用自由，同行以全局变量形式完成 层次式结构相邻层只有单向依赖或者单向调用（结构清晰 有利于移植，维护，扩充） 微内核结构微内核（最核心的服务）+核外服务器（进程，设备管理服务器等） CPU态：（对资源和使用权限的描述） 核态：能够访问所有资源额执行的所有指令；管理程序OS内核 用户态：访问资源受限。用户程序 在硬件层是以“态”区分在CPU层是以“进程”区分 存储器 中断 引入中断的目的：1.实行并发活动（CPU和外设）2.实行实时处理3.故障自动处理 中断响应过程：1.识别中断源2.保护断点和线程3.装入中断服务程序的入口地址（cs:ip）4.进入中断程序5.恢复现场和断点6.中断返回（IRET） 中断的实质：交换指令执行地址交换CPU的态 工作模式实模式 保护模式 BIOS功能系统启动配置基本的设备I/O服务系统的加电自检和启动 按下电源键计算机执行第一条指令是FFFF0的指令(JUMP POST )——&gt;加电自检 (POST )——&gt;初始化CPU、内存、显卡(查找显卡BIOS，调用显卡BIOS，一次查找其他设备的BIOS)——&gt;显示启动画面——&gt;从硬盘、U盘、光驱等读取OS——&gt;OS 启动，OS接管计算机 启动过程1.初始引导（BIOS启动程序，加载MBR的引导程序—GRUB，加载内核OS）2.核心初始化3.系统初始化 主启动记录（MBR）存放在硬盘的首扇区，存放OS启动相关信息，512 bytes,结束：0XAA55h每个分区的首扇区记录主启动记录；主启动扇区：提供菜单（选择不同的OS）；加载核心文件（指向可启动的OS）；跳转（将启动功能交给其他的loader） BIOS和MBR程序运行过程： 用户界面1.操作界面图形用户接口；键盘命令：普通命令，批处理程序，shell 2.系统调用 有唯一的ID 进程管理进程状态运行态:进程占有CPU就绪态：具备运行条件无CPU，暂时不能运行阻塞态：等待某项服务完成或者信号不能运行，等待外设完成相应的I/O操作，等待其他进程给他提供信号 Linux进程的状态 进程控制块PCB是一种描述进程状态，资源，相关进程的数据结构主线程是缺省出来的 忙则等待：当临界区忙，其他进程必须在临界区外等待空闲让进：当没有进程在临界区，任何进程有权进入临界区有限等待：待进入临界区的进程应该有限时间内得到满足让权等待：当在等待进入临界区的进程放弃CPU临界区越小越好 互斥：多个进程共享了独占性资源，确保没有任何两个以上的进程同时进行存取操作同步：合作进程需要满足先后关系，一个进程能否进行取决于某个前提条件，否则只能等待（公交车和售票员） 信号灯进程在运行过程中受信号灯状态的控制，并能改变信号灯状态 P操作用二元矢量表示（S,q） S整数，初始非负，信号量 q PCB队列P操作可能会使进程在调用出阻塞 S初始值很重要 V操作V操作可能会唤醒阻塞的进程 P-V操作解决互斥问题 Q-V操作解决同步问题 生产者消费者同步控制问题 Windows同步机制临界区机制（CREARTE_SECTION）：临界资源的访问（允许一个）EnterCriticalSectionLeaveCriticalSection 互斥量机制跨进程使用（允许一个）CreateMutex 信号量机制允许多个线程/进程访问临界区 并发访问资源WaitForSingleObject()减一ReleaseSemaphore()加一信号量的值大于0 有信号 小于等于0 无信号 事件机制Linux父子进程 父进程等待——&gt;子进程——&gt;exit()——&gt;父进程善后子进程,收回资源，撤回PCB信息。pid_2获取的是子进程的pid_1——&gt;exit() 父子进程共享普通变量int i = 1 即使先运行子进程i= 2，在运行父进程i,他们互不影响。输出子进程i =2;父进程i=1;父子进程共享文件资源父子进程共享同一文件和读写指针。子进程写入，父进程写入 ，最终会一起写入 Windows匿名管道通信仅能用于父子或者兄弟进程通信 1.父进程创建两个管道CreatePipe2.父进程创建子进程CreateProcess3.父进程写入管道14.父进程读取管道2 Linux信号通信机制信号的来源1.键盘输入组合键2.终端命令3.调用函数4.硬件或者内核异常Linux定义了64 中信号编号1——64 父进程fork子进程，发送（kill）自定义信号SIGUSR1，子进程注册信号signal指向handler处理相应要求，exit，然后执行父进程 死锁两个或者多个进程无限期的等待永远不会发生的条件的状态结果没个进程都陷入阻塞 死锁的原因1.系统资源有限,但是系统资源有限不一定会发生死锁2.并发进程推进顺序不当 进程请求释放资源顺序不当 假设A先运行 当运行到第5行时，运行B，此时j 被占用B在第二行阻塞，然后返回A知道第7行之后被释放继续运行B，并没有导致死锁 假设A先运行，当运行到第4行时，运行B，B在第4行j 被占用阻塞，使用i，i被占用进程A也被阻塞，导致死锁 3.不正确的P-V操作也会带来死锁（消费者和生产者例子的P-V顺序使用不当） 死锁的必要条件1.互斥条件：进程互斥使用资源，资源具有独占性2.不剥夺条件：进程访问资源前，不被其他进程强行剥夺3.部分分配条件：临时需要临时分配4.环路条件 解决死锁的策略1.预防死锁 通过设置某些条件，破坏死锁的必要条件 由于限制太严格，资源利用率低2.避免死锁 若分配资源是否会让系统进入死锁状态，是，拒绝分配资源。很难实现3.检测恢复死锁 先检测恢发生死锁，然后清除死锁 实现难度大4.预先静态分配法 破坏部分分配条件：运行进程前，将所需资源一次性全部分配 开销大，利用率低，延迟5.有序资源分配 破坏环路条件 给每个资源分配一个序号；进程每次申请资源时，只能申请序号更大的资源 ●按有序资源分配法分配资源并发进程不会发生死锁（序号递增）●操作系统没有死锁解决方案，留给用户解决 进程调度算法1.先来先服务只考虑时间，不利于短作业2.短作业优先调度算法不利于长作业，易出现饥饿现象3.响应比高优先调度算法响应比=1+等待时间/运行时间，有利于短作业或者长作业（兼顾）4.优先数调度算法优先数=静态优先数+动态优先数静态：进程所需资源；运行时间长短；进程的类型（IO/CPU，前台/后台，核心/用户）动态：使用CPU超过一定时长时（大进程降低优先数）；当进行I/O操作后（增加优先数）；当进程等待时间超过一定时间后（增加优先数）5.循环轮转调度算法先进先出排成队列，进程以时间片段q轮流使用CPU，队列逻辑上形成环形公平性：每个进程都平等的有机会获得CPU交互性：每个进程等待（N-1）*q的时间可以重新获得CPU若q太大相当于先来先服务若q太小进程切换频繁，系统开销大 Linux进程调度普通进程：采用动态优先级。进程占用CPU，优先级随时间流失减小 task_struct 的counter表示动态优先级实时进程：静态优先级。 进程创建时指定或者优用户修改 先进先出 时间片轮转 新建子进程counter从父进程时间片counter中继承一半 进程调度不同的进程有不同的调度需求（linux中进程优先级是动态的）进程调度时机（schedule函数内核函数，用户态不能直接调用schedule）：中断处理过程（包括时钟中断、IO中断、系统调用、异常）中,直接调用schedule；或者返回用户态时根据need_resched标记调用schedule内核线程（是一个没有用户态只有内核态的特殊的进程，没有系统调用但可以发生中断，在发生中断的时候可以调用schedule）可以直接调用schedule进行进程切换。用户态无法主动调度，只能通过陷入内核状态后的某个时机进行调度，即中断处理过程中 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上执行的进程，并且恢复以前挂起的某个进程的执行进程上下文包含了进程执行需要的所有信息： 1.用户地址空间（代码，数据，用户堆栈等）2.控制信息（进程描述符，内核堆栈）3.硬件上下文 Schedule函数选择新的进程来运行，调用context_switch进行切换，这个宏调用switch_to (prev指向当前进程，next指向被调度的进程) 下一篇继续记录（来自华中科技大学操作系统原理学习）","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"PandArray","slug":"PandArray","date":"2020-03-31T03:46:55.000Z","updated":"2020-03-31T04:10:49.292Z","comments":true,"path":"2020/03/31/PandArray/","link":"","permalink":"/2020/03/31/PandArray/","excerpt":"","text":"char *str1 = &quot;lilei&quot;; //(1) char str2[] = &quot;lilei&quot;; //(2) 这里是定义，不是声明，因为两个字符串都分配了空间（1）是一个指针变量 保存在字符串常量区不能被修改，（2）是一个数组 #include &quot;stdio.h&quot; #include &quot;stdlib.h&quot; #include &quot;string.h&quot; int main(void) { char *str1 = &quot;lilei&quot;; char *str3 = &quot;lilei&quot;; char str2[] = &quot;lilei&quot;; memcpy(str1,&quot;hello&quot;,strlen(&quot;hello&quot;)+1); //向一个非法的地址拷贝东西，错误 str1[1] = &#39;a&#39;; //错误 操作非法的地址 str2[1] = &#39;a&#39; //允许 printf(&quot;str1:%s str3:%s\\n str2:%s\\n&quot;,str1,str3,str2); str3 = &quot;world&quot;; //指针变量保存的地址是可以变化的 str3的值会变成world printf(&quot;str1:%s str3:%s str2:%s\\n&quot;,str1,str3,str2); printf(&quot;hello,world\\n&quot;); return (0); } #include &lt;stdio.h&gt; #include &quot;stdlib.h&quot; #include &quot;string.h&quot; const int a = 1; const int a1 = 1; char * s = &quot;hello&quot;; int main() { const int b = 2; const int b1 = 2; char * s1 = &quot;hello&quot;; printf(&quot;s:%p s1:%p\\n&quot;,s,s1); printf(&quot;a:%p a1:%p b:%p b1:%p\\n&quot;,&amp;a,&amp;a1,&amp;b,&amp;b1); return 1; } 输出 s:0000000000404008 s1:0000000000404008 a:0000000000404000 a1:0000000000404004 b:000000000062FE14 b1:000000000062FE10 -------------------------------- s,s1,a,a1在一个内存区域。这个内存区域的内容是不允许改变的。 对于以上代码 const int b = 2; int main() { const int b1 = 2; int *p = &lt;font color=red&gt;&amp;b1&lt;/font&gt;;; printf(&quot;b1:%d\\n&quot;,b1); *p = 3; printf(&quot;b1:%d\\n&quot;,b1); //输出 b1=2 b1 = 3 const int b1 = 2; int *p = &lt;font color=red&gt;&amp;b&lt;/font&gt;; printf(&quot;b:%d\\n&quot;,b); *p = 3; //错误 printf(&quot;b:%d\\n&quot;,b); //输出 b1=2 return 1; }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"CPPInterview","slug":"CPPInterview","date":"2020-03-30T02:44:57.000Z","updated":"2020-03-30T03:58:03.480Z","comments":true,"path":"2020/03/30/CPPInterview/","link":"","permalink":"/2020/03/30/CPPInterview/","excerpt":"","text":"分享别人的C++面试问题 gdb调试命令step和next的区别当前line有函数调用的时候,next会直接执行到下一句（F11）,step会进入函数（F10）。 查看内存$(gdb)p &amp;a //打印变量地址 $(gdb)x 0xbffff543 //查看内存单元内变量 $0xbffff543: 0x12345678 $(gdb)x/4xb 0xbffff543 //单字节查看4个内存单元变量的值 $0xbffff543: 0x78 0x56 0x34 0x12 } 多线程调试$(gdb) info threads：查看GDB当前调试的程序的各个线程的相关信息 $(gdb) thread threadno：切换当前线程到由threadno指定的线程 $break filename:linenum thread all 在所有线程相应行设置断点，注意如果主线程不会执行到该行，并且启动all-stop模式，主线程执行n或s会切换过去 $set scheduler-locking off|on\\step 默认off，执行s或c其它线程也同步执行。on，只有当前线程执行。step，只有当前线程执行 $show scheduler-locking 显示当前模式 $thread apply all command 每个线程执行同意命令，如bt。或者thread apply 1 3 bt，即线程1，3执行bt。 查看调用堆栈$(gdb)bt $(gdb)f 1 帧简略信息 $(gdb)info f 1 帧详细信息 断点b test.cpp:11 b test.cpp:main gdb attach 调试方法： gdb-&gt;file xxxx-&gt;attach pid-&gt;这时候进程是停止的-&gt;c 继续运行 带参数调试输入参数命令set args 后面加上程序所要用的参数，注意，不再带有程序名，直接加参数，如： (gdb)set args -l a -C abc list命令list linenum 显示程序第linenum行的周围的程序 list function 显示程序名为function的函数的源程序 软硬链接ln -s 源文件 目标文件, ln -s / /home/good/linkname链接根目录/到/home/good/linkname 1、软链接就是：“ln –s 源文件 目标文件”，只会在选定的位置上生成一个文件的镜像，不会占用磁盘空间，类似于windows的快捷方式。2、硬链接ln源文件目标文件，没有参数-s， 会在选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 函数指针函数指针 int (*func)(int, int) 函数指针数组 int (*funcArry[10])(int, int) const int* p; 指向const int的指针 int* const p; const指针 设计模式单例模式一对一● 1、单例类只能有一个实例。● 2、单例类必须自己创建自己的唯一实例。● 3、单例类必须给所有其他对象提供这一实例。比如：● 1、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。● 2、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 观察者模式一对多● (也叫发布订阅模式)当一个对象被修改时，则会自动通知它的依赖对象 工厂模式三种：简单工厂模式、工厂方法模式、抽象工厂模式 为什么要用工厂模式？原因就是对上层的使用者隔离对象创建的过程；或者是对象创建的过程复杂，使用者不容易掌握；或者是对象创建要满足某种条件，这些条件是业务的需求也好，是系统约束也好，没有必要让上层使用者掌握，增加别人开发的难度。所以，到这时我们应该清楚了，无论是工厂模式，还是开闭原则，都是为了隔离一些复杂的过程，使得这些复杂的过程不向外暴露，如果暴露了这些过程，会对使用者增加麻烦，这也就是所谓的团队合作。 大小端转化 #define BigLittleSwap32(A) ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24)| \\ (((uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8) | \\ (((uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8) | \\ (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24)) IO多路复用为什么 IO 多路复用要搭配非阻塞IOselect和read两个操作相互独立且存在窗口，select返回可读并不能保证read一定可读，存在多种情况，select返回可读，但是read无数据可读● 多进程同时对某个socket进行监听，当新的连接完成3次握手后，进程均被select,epoll唤醒，但是最后只有1个进程可以accept，没能accept的进程被block● 某个socket接收缓冲区有新数据分节到达，然后select报告这个socket描述符可读，但随后，协议栈检查到这个新分节检验和错误，然后丢弃这个分节，这时候调用read则无数据可读● 边缘触发环境，由于无法知道多少数据可读，所以accept1次后，第二次尝试accept可能会被阻塞，此时应该使用非阻塞IO 设置非阻塞 io fcntl(sockfd, F_SETFL, O_NONBLOCK);","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"Lifetink","slug":"Lifetink","date":"2020-03-30T02:36:01.000Z","updated":"2020-03-30T02:40:14.287Z","comments":true,"path":"2020/03/30/Lifetink/","link":"","permalink":"/2020/03/30/Lifetink/","excerpt":"","text":"热爱生活热爱自己热爱技术加入生活辜负了你，却不要辜负生活","categories":[{"name":"think","slug":"think","permalink":"/categories/think/"}],"tags":[],"keywords":[{"name":"think","slug":"think","permalink":"/categories/think/"}]},{"title":"Test","slug":"Test","date":"2020-03-29T06:59:14.000Z","updated":"2020-04-02T07:59:29.178Z","comments":true,"path":"2020/03/29/Test/","link":"","permalink":"/2020/03/29/Test/","excerpt":"","text":"很高兴您访问raylee,和我一起学习吧！ 不可重入函数:$ Int g=0; $ Int function(){ $ g++; //执行另一个线程执行 $ printf(“%dg值：” g); }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"newTest","slug":"newTest","date":"2020-03-28T12:54:04.000Z","updated":"2020-03-29T09:22:09.878Z","comments":true,"path":"2020/03/28/newTest/","link":"","permalink":"/2020/03/28/newTest/","excerpt":"","text":"很高兴您访问raylee,和我一起学习吧！ 不可重入函数:$ Int g=0; $ Int function(){ $ g++; //执行另一个线程执行 $ printf(“%dg值：” g); }","categories":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}],"tags":[],"keywords":[{"name":"technology","slug":"technology","permalink":"/categories/technology/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-28T04:59:27.977Z","updated":"2020-03-28T04:59:27.978Z","comments":true,"path":"2020/03/28/hello-world/","link":"","permalink":"/2020/03/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}